---
import ComposersPage from "../components/ComposersPage.jsx";
---
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Composers results - Archive of Soviet Trumpet Music</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/styles/composers.css">
      <style>
    :root { --accent:#8b0000; --muted:#6b7280; --bg:#f7f9fc; }
    * { box-sizing:border-box; }
    body {
      font-family: Inter, system-ui, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      margin: 0;
      color: #0f172a;
      background-color: var(--bg);
      background-image: none;
      /* ensure there's room for the fixed footer and device safe-area inset */
      padding-bottom: calc(120px + env(safe-area-inset-bottom, 0px)); /* reserve space for fixed footer */
      padding-top: 112px; /* reserve space for fixed header + search strip */
    }

    /* Ensure the fixed footer is visible on all screen sizes (override mobile-only rules) */
    #fixed-footer { display: block !important; visibility: visible !important; z-index: 99999 !important; }

    header {
      background:white; 
      border-bottom:1px solid #e6e9ef; 
      position:sticky; 
      top:0; 
      z-index:1000; /* ensure header sits above overlays */
      height:64px; /* explicit height so search strip can sit flush below */
      display:flex; align-items:center;
    }

  /* Header: span full width so title can be flush left; language selector sits flush right via flex */
  /* header container: remove vertical padding so search strip sits flush */
  header .container { width:100%; max-width:none; margin:0; padding:0 20px; }
  /* top title absolutely flush left (no left padding) */
  #navEnglish { display:inline-block; padding-left:0; }
    .container { max-width:1100px; margin:0 auto; padding:20px; }

    .nav { display:flex; align-items:center; gap:18px; }
  .logo { font-weight:800; color:var(--accent); font-size:20px; }
  .logo a { color:inherit; text-decoration:none; display:inline-flex; gap:8px; align-items:center; }
  .logo a:focus { outline:3px solid rgba(139,0,0,0.12); border-radius:6px; }
    .nav-english { color:var(--accent); font-weight:800; }
    .nav-pipe { color:#000; margin:0 8px; }
    .nav-russian { color:var(--muted); }

    /* language toggle */
    .lang-toggle { position:relative; display:inline-block; margin-right:12px; }
    .lang-btn { background:transparent; border:1px solid #e6e9ef; padding:6px 8px; border-radius:6px; cursor:pointer; font-weight:600; }
    .lang-dropdown { position:absolute; top:100%; right:0; background:white; border:1px solid #e6e9ef; border-radius:6px; padding:6px; box-shadow:0 6px 18px rgba(16,24,40,0.06); display:none; min-width:140px; }
    .lang-dropdown.open { display:block; }
    .lang-option { padding:6px 8px; cursor:pointer; }
    .lang-option:hover { background:#f3f4f6; }

    /* Hero & search panel (reduced to essentials used by results page) */
    .search-bar { display:flex; gap:8px; padding:12px 20px; }
    .search-input, #qinput { flex:1; padding:10px 12px; border-radius:8px; border:1px solid #e5e7eb; }
    .search-cta, #qbtn { padding:10px 12px; border-radius:8px; background:var(--accent); color:white; border:none; font-weight:700; cursor:pointer; }

  .filters { width:305px; }
  .results { flex:1; }
  .composer-box { width:345px; }
    .section-divider { height:1px; background:#e6e9ef; margin:8px 0; }

  /* Fixed translucent search strip under the navbar */
  .search-strip { position:fixed; left:0; right:0; top:64px; z-index:1400; background: rgba(128,128,128,0.75); padding:12px 0; }
  .search-center { max-width:1100px; margin:0 auto; padding:0 20px; display:flex; align-items:center; gap:8px; box-sizing:border-box; }
  .search-center #qinput { flex:1; padding:12px 14px; border-radius:10px; border:1px solid rgba(0,0,0,0.12); background:white; min-width:0; }
  .search-center #qbtn { padding:12px 16px; border-radius:10px; background:var(--accent); color:white; border:none; font-weight:700; cursor:pointer; }
  /* three horizontal panels below the search strip
    Layout: full-width container with 20px side padding so
    the left panel sits 20px from the left edge and the right
    panel sits 20px from the right edge. Left/right panels
    use fixed widths; center panel is fluid. */
    .three-panels { display:flex; gap:16px; width:100%; margin:45px 0 0 0; padding:0 20px; box-sizing:border-box; overflow-x:hidden; align-items:stretch; }
  /* left filter panel (anchored 20px from left) */
  .three-panels .panel:first-child { width:270px; flex:0 0 270px; }
  /* center results panel (flexible) */
  .three-panels .panel:nth-child(2) { flex:1 1 auto; min-width:0; }
  /* right composer panel (anchored 20px from right) */
  .three-panels .panel:last-child { width:345px; flex:0 0 345px; }
    /* Ensure panels constrain overflowing children and allow flex shrinking properly */
    .three-panels .panel {
      max-width: 100%;
      min-width: 0; /* allow flex children to shrink and respect container */
      overflow-wrap: break-word;
      word-break: break-word;
    }

    /* Prevent long inline content inside cards from breaking layout */
    .result-card,
    .result-main,
    .result-right {
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: normal; /* allow wrapping, avoid nowrap from injected content */
    }
  .three-panels .panel { background:white; border-radius:8px; padding:16px; box-shadow:0 6px 12px rgba(15,23,42,0.06); min-height:140px; box-sizing:border-box; position:relative; z-index:1; }
  /* Results item styling: separator line between entries and right-side details column */
  .result-item { padding:12px 0; border-bottom:1px solid #e6e9ef; display:flex; justify-content:space-between; align-items:center; gap:12px; }
  .result-item:last-child { border-bottom: none; }
  /* Position details link at the upper-right of the item */
  .result-item { position: relative; padding: 16px 0 20px 0; }
  .result-item .result-main { flex:1 1 auto; margin-right:180px; }
  .result-item .result-right { position: absolute; right:16px; top:12px; width:auto; flex:0 0 auto; text-align:right; color:#6b7280; font-size:0.95rem; display:flex; align-items:center; justify-content:flex-end; }
  .result-item .details-link { color:var(--accent); text-decoration:none; font-weight:700; }
  /* Make the small 'About this composer' label look and behave like a clickable control (visual only) */
  .about-label, .about-badge { background: transparent; border: 0; padding: 0; margin: 0 6px 0 0; color: #6b7280; font-size:0.95rem; cursor: pointer; display: inline-block; }
  .about-label:active, .about-badge:active { transform: translateY(1px); opacity: 0.9; }
  /* panel title + divider */
  .panel-title { margin:0 0 8px; font-weight:700; color:var(--accent); font-size:16px; }
  .panel-divider { height:1px; background:#e6e9ef; margin:8px 0 12px 0; }
  /* pagination styles */
  .pagination { display:flex; gap:8px; align-items:center; }
  .pagination { background: #fff; padding:6px; border-radius:6px; color: #0f172a; }
  /* New filter-panel styles */
  .filter-panel {
    width: 270px;
    background: #f9fafb;
    border-right: 1px solid #e5e7eb;
    padding: 20px;
    font-family: Inter, system-ui, sans-serif;
  }

  .filter-title {
    font-size: 18px;
    font-weight: 700;
    margin-bottom: 18px;
    color: #1f2937;
    border-bottom: 2px solid #e5e7eb;
    padding-bottom: 6px;
  }

  .filter-box {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  .filter-group {
    background: #fff;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 12px 10px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
  }

  .filter-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }

  .filter-group h4 {
    font-size: 15px;
    font-weight: 600;
    color: #111827;
    margin: 0;
  }

  .filter-options {
    display: flex;
    flex-direction: column;
    gap: 5px;
    font-size: 14px;
    color: #374151;
  }

  .filter-options label {
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
    padding: 4px 6px;
    border-radius: 6px;
    transition: background 0.15s ease;
  }

  .filter-options label:hover {
    background: #f3f4f6;
  }

  input[type="checkbox"] {
    accent-color: #2563eb;
    width: 15px;
    height: 15px;
  }

  .filter-actions {
    display: flex;
    gap: 6px;
  }

  .small-action {
    background: none;
    border: none;
    color: #2563eb;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 4px;
  }

  .small-action:hover {
    background: #e0e7ff;
  }
  .pagination .page-btn { display:inline-flex; align-items:center; justify-content:center; min-width:36px; height:36px; padding:0 10px; border-radius:8px; border:1px solid #e6e9ef; background:#fff; color:#0f172a; cursor:pointer; font-weight:600; }
  .pagination .page-btn:hover { background:#f3f4f6; }
  .pagination .page-btn[aria-current="true"] { background:var(--accent); color:#fff; border-color:var(--accent); }
  .pagination .page-ellipsis { padding:0 6px; color:var(--muted); }
  .pagination .pager-controls { display:flex; gap:8px; align-items:center; }

  /* Result card styles for center panel */
  /* Result card styles for center panel */

<script>
  // Example data
  const results = [
    { title: "Concert scherzo", composer: "Abramyan, Eduard Aslanovich", published: 1957 },
    { title: "Sonata", composer: "Asafiev, Boris Vladimirovich", published: 1950 },
    { title: "Scherzo", composer: "Tchaikovsky, Pyotr", published: 1880 },
    { title: "Symphony No.1", composer: "Shostakovich, Dmitri", published: 1926 },
    // ...add more results
  ];

  const resultsPerPage = 2;
  let currentPage = 1;

  const resultsList = document.getElementById("results-list");
  const pagination = document.getElementById("pagination");

  function renderResults() {
    resultsList.innerHTML = "";

    const start = (currentPage - 1) * resultsPerPage;
    const end = start + resultsPerPage;
    const pageResults = results.slice(start, end);

    pageResults.forEach(item => {
      const card = document.createElement("div");
      card.className = "result-card";

      const main = document.createElement("div");
      main.className = "result-main";
      main.innerHTML = `
        Results<br>
        ${item.title}<br>
        Composer: ${item.composer}<br>
        Published: ${item.published}
      `;

      const right = document.createElement("div");
      right.className = "result-right";

      const viewLink = document.createElement("a");
      viewLink.href = "#";
      viewLink.textContent = "View";

      const moreBtn = document.createElement("button");
      moreBtn.className = "more-composer-btn";
      moreBtn.textContent = "More from this composer";
      moreBtn.onclick = () => filterByComposer(item.composer);

      right.appendChild(viewLink);
      right.appendChild(moreBtn);

      card.appendChild(main);
      card.appendChild(right);

      resultsList.appendChild(card);
    });
  }

  function renderPagination() {
    pagination.innerHTML = "";

    const totalPages = Math.ceil(results.length / resultsPerPage);

    const prevBtn = document.createElement("button");
    prevBtn.className = "page-btn page-arrow";
    prevBtn.innerHTML = "&lt;";
    prevBtn.disabled = currentPage === 1;
    prevBtn.onclick = () => { currentPage--; update(); };
    pagination.appendChild(prevBtn);

    for (let i = 1; i <= totalPages; i++) {
      const pageBtn = document.createElement("button");
      pageBtn.className = "page-btn";
      pageBtn.textContent = i;
      if (i === currentPage) pageBtn.setAttribute("aria-current", "true");
      pageBtn.onclick = () => { currentPage = i; update(); };
      pagination.appendChild(pageBtn);
    }

    const nextBtn = document.createElement("button");
    nextBtn.className = "page-btn page-arrow";
    nextBtn.innerHTML = "&gt;";
    nextBtn.disabled = currentPage === totalPages;
    nextBtn.onclick = () => { currentPage++; update(); };
    pagination.appendChild(nextBtn);
  }

  function update() {
    renderResults();
    renderPagination();
  }
  // Initial render
  update();
</script>

    @media (max-width:900px) { .grid { grid-template-columns:repeat(2,1fr); } }
    @media (max-width:600px) { .grid{grid-template-columns:1fr;} .search-row{flex-direction:column;} .container{padding:14px;} }

    /* Mobile toolbar overlaying footer (visible on small screens, full-width) */
    .mobile-footer-toolbar { display:none; }
    @media (max-width:600px) {
  .mobile-footer-toolbar { display:flex; position:fixed; left:0; right:0; bottom:0; box-sizing:border-box; height:56px; background:rgba(255,255,255,0.98); align-items:center; justify-content:space-between; padding:0 calc(12px + env(safe-area-inset-left)) calc(8px + env(safe-area-inset-bottom)); gap:12px; z-index:100001; box-shadow:0 -6px 18px rgba(11,15,30,0.08); backdrop-filter: blur(6px); margin:0; pointer-events:auto; }
  .mobile-footer-toolbar .mf-btn { flex:0 0 auto; border:1px solid #e6e9ef; background:#fff; padding:8px 12px; border-radius:10px; font-weight:700; color:var(--accent); cursor:pointer; }
      /* make hamburger inline on the bar (no red circular center) */
      .mobile-footer-toolbar .mf-center { position:static; transform:none; width:auto; height:auto; border-radius:8px; display:inline-flex; align-items:center; justify-content:center; background:transparent; color:var(--accent); box-shadow:none; border:1px solid #e6e9ef; padding:8px 12px; }
  /* ensure toolbar overlays footer */
  /* Fixed footer: bring in the same styling used on the main composers page */
  footer { margin-top:40px; padding:36px 0; }
  /* Fixed footer bar locked to viewport (shared with main site) */
  /* Fixed footer: always visible and above other overlays */
  #fixed-footer { position:fixed; left:0; right:0; bottom:0; background-color:#8b0000 !important; color:white !important; z-index:99999; box-shadow:0 -6px 18px rgba(11,10,10,0.2); padding:8px 0 calc(8px + env(safe-area-inset-bottom, 0px)) 0; display:block; visibility:visible; }
  /* On small screens we hide the desktop header and the fixed footer
     and show compact mobile replacements (topbar + mobile toolbar). */
  /* Remove the hard-hide so the mobile toolbar can be used as the footer replacement. */
  /* The existing mobile toolbar styles above will take effect at <=600px. */

  /* Desktop footer remains visible by default; on mobile it will be hidden. */
  /* We define explicit mobile rules below to ensure predictable layout. */
  @media (max-width:600px) {
    /* Hide the large desktop header and the fixed footer bar on small screens */
    header { display: none !important; }
    #fixed-footer { display: none !important; }

    /* Show the mobile footer toolbar (replacement) */
    .mobile-footer-toolbar { display: flex !important; }

    /* Reserve room for the mobile topbar + search strip so content isn't hidden */
    body { padding-top: calc(56px + 64px); }

    /* Mini mobile topbar (defined below in markup) will be shown */
    .mobile-topbar { display: flex !important; }
  }
  /* center the footer content to match site layout and keep a comfortable max width */
  .fixed-footer-inner { width:100%; max-width:1100px; margin:0 auto; padding:8px 20px; display:flex; gap:12px; justify-content:space-between; align-items:center; }
  .footer-grid { display:flex; gap:24px; flex-wrap:wrap; }
  .footer-left { display:flex; flex-direction:column; transform: translateY(-5px); }
  .footer-left .title { font-weight:700; color:white; font-size:16px; line-height:1.1; padding:12px 0 0 0; margin-left:0; }
  .footer-left .subtitle { color:rgba(255,255,255,0.8); font-size:13px; margin-top:0; margin-left:0; padding-left:0; }
  .fixed-footer-right { display:flex; align-items:center; }
  .fixed-footer-center { flex:1; display:flex; align-items:center; justify-content:center; transform: translateY(-3px); }
  .fixed-footer-center .links { color:white; font-size:13px; text-align:center; }
  .fixed-footer-center .links a { color:inherit; text-decoration:none; margin:0 8px; }
  .fixed-footer-right { display:flex; align-items:center; justify-content:flex-end; min-width:220px; transform: translateY(-3px); }
  .fixed-footer-right .copyright { color:rgba(255,255,255,0.9); font-size:13px; }
      /* make room for toolbar so content isn't hidden */
      body { padding-bottom: calc(64px + 56px); }
    }

  /* keep fixed footer visible on small screens (always in viewport) */

    /* Make header and search strip adapt to small screens */
    @media (max-width:600px) {
      header .container { padding: 10px 14px; }
      .search-strip { top:64px; }
      /* limit total search control width to screen width minus 30px (15px padding each side) */
      .search-center { padding: 0; max-width: none; width: calc(100% - 30px); margin: 0 15px; }
      .search-center #qinput { border-radius:8px; width:100%; min-width:0; }
      .search-center #qbtn { flex: 0 0 auto; }
    }

    /* On small screens collapse the left and right panels; open as overlays when requested */
    @media (max-width:600px) {
      /* hide the side panels in the main layout so center takes full width */
      .three-panels .panel:first-child, .three-panels .panel:last-child { display: none !important; }
      .three-panels { margin-top: 28px; }
      .three-panels .panel:nth-child(2) { width:100%; padding-bottom: 120px; }

      /* full-screen overlay for mobile panels */
      .mobile-overlay { display: none; position: fixed; inset: 0; z-index: 2200; background: rgba(0,0,0,0.45); backdrop-filter: blur(4px); }
      .mobile-overlay.open { display: block; }
      .mobile-overlay .overlay-inner { position: absolute; left: 0; right: 0; top: 64px; bottom: 56px; margin: 0; background: white; overflow: auto; padding: 16px; box-sizing: border-box; will-change: transform, opacity; transform: translateY(8px); opacity: 0; transition: transform 200ms ease, opacity 200ms ease; border-top-left-radius: 12px; border-top-right-radius:12px; }
      .mobile-overlay.open .overlay-inner { transform: translateY(0); opacity: 1; }
      .mobile-overlay .overlay-close { position: absolute; right: 12px; top: 72px; z-index: 2300; border: 0; background: #fff; border-radius: 8px; padding: 8px 10px; box-shadow: 0 6px 12px rgba(0,0,0,0.08); }
    }

    /* swipe menu (left-side sliding) */
    .mobile-swipe-menu { display:none; position:fixed; inset:0; z-index:2100; pointer-events:none; }
    .mobile-swipe-menu[aria-hidden="false"] { display:block; pointer-events:auto; }
  .mobile-swipe-menu .swipe-inner { position:absolute; left:0; top:64px; bottom:56px; width:84%; max-width:380px; background:white; transform:translateX(-8%); opacity:0; transition:transform 220ms ease, opacity 220ms ease; box-shadow: 6px 0 18px rgba(0,0,0,0.12); border-top-right-radius:12px; border-bottom-right-radius:12px; overflow:auto; -webkit-overflow-scrolling: touch; overscroll-behavior: contain; touch-action: pan-y; }
    .mobile-swipe-menu[aria-hidden="false"] .swipe-inner { transform:translateX(0); opacity:1; }
    .swm-close { position:absolute; right:10px; top:8px; }
    .swm-item { display:block; width:100%; text-align:left; margin:8px 0; padding:10px 12px; border-radius:8px; border:1px solid #e6e9ef; background:#fff; }

  /* background overlay removed for now */
  /* background overlay: ensure it sits behind content and doesn't intercept clicks */
  #bg-overlay { position:fixed; inset:0; z-index:-1; overflow:hidden; pointer-events:none; }

  /* Mobile-only side panel styles (hidden by default) */
  #mobileSidePanel { 
    display: none; /* hidden by default */
    background: white;
    padding: 16px;
    position: fixed;
    z-index: 1300;
    box-shadow: 0 -6px 18px rgba(0,0,0,0.08);
    font-size: 15px;
  }

  /* Disable background scrolling when a full-screen mobile panel is open
     Use overflow:hidden only — do NOT apply position:fixed here, it prevents
     the fixed-position mobile panel from scrolling independently. */
  body.no-scroll, html.no-scroll {
    overflow: hidden 
  }
  /* Toggle button - only show on mobile */
  .mobile-toggle { display: none; border:0; background:transparent; font-size:16px; cursor:pointer; padding:6px 8px; }
  /* On small screens make the mobile panel a right-side sliding panel matching the filter width (270px) */
      @media (max-width: 600px) {
    #mobileSidePanel {
    display: block;
      /* span the full viewport vertically */
      top: 0; /* extend to very top */
      bottom: 0; /* extend to very bottom */
      right: 0;
      left: auto;
  /* extend to 60px from the left edge on small screens */
  width: calc(100vw - 60px);
  max-width: 92%;
      /* match filter panel styling */
      background: #f9fafb;
      color: inherit;
      /* include safe-area padding so content doesn't collide with device insets */
      padding: calc(20px + env(safe-area-inset-top, 0px)) 20px calc(20px + env(safe-area-inset-bottom, 0px));
      border-left: 1px solid #e5e7eb;
      border-top: none;
      /* rounded left corners, subtle shadow like filter panel */
      border-radius: 8px 0 0 8px;
      box-shadow: 0 6px 12px rgba(15,23,42,0.06);
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      z-index: 2200;
      font-family: Inter, system-ui, sans-serif;
  height: 100vh; /* ensure it fills the viewport */
  left: auto; right: 0; transform: translateX(0);
    }
    .mobile-toggle { display: inline-block; }
  }
  #bg-overlay img { position:absolute; left:0; top:0; width:100vw; height:100vh; object-fit:cover; will-change:left,top,width,height; pointer-events:none; }
  .search-panel, .search-panel.fixed, .search-cta, .search-input, .cta-row a, .lang-btn, .lang-dropdown, .filters select, .small-btn, .reset-btn { position:relative; z-index:2000; pointer-events:auto; }
    </style>
  </head>
  <body>
    <!-- background overlay removed -->
  <header style="position:fixed;left:0;right:0;top:0;z-index:1500;background:white;">
    <div class="container nav" style="display:flex;justify-content:space-between;align-items:center">
      <div class="logo">
        <a href="/composers" aria-label="Back to composers" title="Back to composers">
          <span class="nav-english" id="navEnglish">Archive of Soviet Trumpet Music</span>
          <span class="nav-pipe">|</span>
          <span class="nav-russian" id="navRussian" lang="ru" style="font-family: 'Segoe UI', 'Noto Sans', Arial, sans-serif;">Архив советской трубной музыки</span>
        </a>
      </div>
      <div class="lang-toggle" id="langToggle">
        <button class="lang-btn" id="langBtn">EN ▾</button>
        <div class="lang-dropdown" id="langDropdown">
          <div class="lang-option" data-locale="en">English</div>
          <div class="lang-option" data-locale="de">Deutsch</div>
        </div>
      </div>
      <!-- Mobile panel toggle (moved from composers.astro) -->
      <div style="display:inline-block; margin-left:8px;">
        <button id="togglePanelBtn" class="mobile-toggle" aria-label="Open mobile panel">☰</button>
      </div>
    </div>
  </header>
  <!-- Mobile topbar: simple white bar with left-aligned title for small screens -->
  <div class="mobile-topbar" aria-hidden="true">
    <div class="mobile-topbar-inner">
      <div class="mobile-title">Archive of Soviet Trumpet Music</div>
    </div>
  </div>
  <script>
    // Force English locale on this results page to keep filter labels consistent
    try{ localStorage.setItem('locale','en'); }catch(e){}
  </script>
    <!-- fixed translucent search strip centered under the navbar (flush with nav) -->
    <div class="search-strip" aria-hidden="false">
      <div class="search-center">
        <input id="qinput" type="text" placeholder="Search composers, countries, or pieces..." />
        <button id="qbtn">Search</button>
      </div>
    </div>
    <!-- three horizontal panels, 20px below the search strip -->
    <div class="three-panels" role="region" aria-label="Quick panels">
      <aside class="panel filter-panel" id="panel-left">
        <h3 class="filter-title">Filters</h3>

        <div class="filter-box">

          <!-- COUNTRY -->
          <div class="filter-group" data-group="country">
            <div class="filter-header">
              <h4>Country</h4>
              <div class="filter-actions"></div>
            </div>
            <div class="filter-options" id="filter-country">
              <label><input type="checkbox" name="country" value="Russia" data-val="Russia"> Russia</label>
              <label><input type="checkbox" name="country" value="Ukraine" data-val="Ukraine"> Ukraine</label>
              <label><input type="checkbox" name="country" value="Belarus" data-val="Belarus"> Belarus</label>
              <label><input type="checkbox" name="country" value="Armenia" data-val="Armenia"> Armenia</label>
              <label><input type="checkbox" name="country" value="Georgia" data-val="Georgia"> Georgia</label>
              <label><input type="checkbox" name="country" value="Latvia" data-val="Latvia"> Latvia</label>
              <label><input type="checkbox" name="country" value="Estonia" data-val="Estonia"> Estonia</label>
              <label><input type="checkbox" name="country" value="Lithuania" data-val="Lithuania"> Lithuania</label>
              <label><input type="checkbox" name="country" value="Kazakhstan" data-val="Kazakhstan"> Kazakhstan</label>
              <label><input type="checkbox" name="country" value="Uzbekistan" data-val="Uzbekistan"> Uzbekistan</label>
              <label><input type="checkbox" name="country" value="Other" data-val="Other"> Other</label>
            </div>
                 <div class="filter-actions">
                   <button class="small-action select-all">Select all</button>
                   <button class="small-action clear-all">Clear all</button>
                 </div>
          </div>

          <!-- REPUBLIC -->
          <div class="filter-group" data-group="republic">
            <div class="filter-header">
              <h4>Soviet Republic</h4>
              <div class="filter-actions"></div>
            </div>
            <div class="filter-options" id="filter-republic">
              <label><input type="checkbox" name="republic" value="Russian SFSR" data-val="Russian SFSR"> Russian SFSR</label>
              <label><input type="checkbox" name="republic" value="Ukrainian SSR" data-val="Ukrainian SSR"> Ukrainian SSR</label>
              <label><input type="checkbox" name="republic" value="Byelorussian SSR" data-val="Byelorussian SSR"> Byelorussian SSR</label>
              <label><input type="checkbox" name="republic" value="Armenian SSR" data-val="Armenian SSR"> Armenian SSR</label>
              <label><input type="checkbox" name="republic" value="Georgian SSR" data-val="Georgian SSR"> Georgian SSR</label>
              <label><input type="checkbox" name="republic" value="Latvian SSR" data-val="Latvian SSR"> Latvian SSR</label>
              <label><input type="checkbox" name="republic" value="Estonian SSR" data-val="Estonian SSR"> Estonian SSR</label>
              <label><input type="checkbox" name="republic" value="Lithuanian SSR" data-val="Lithuanian SSR"> Lithuanian SSR</label>
              <label><input type="checkbox" name="republic" value="Kazakh SSR" data-val="Kazakh SSR"> Kazakh SSR</label>
              <label><input type="checkbox" name="republic" value="Uzbek SSR" data-val="Uzbek SSR"> Uzbek SSR</label>
              <label><input type="checkbox" name="republic" value="North Ossetian ASSR" data-val="North Ossetian ASSR"> North Ossetian ASSR</label>
              <label><input type="checkbox" name="republic" value="Chuvash ASSR" data-val="Chuvash ASSR"> Chuvash ASSR</label>
              <label><input type="checkbox" name="republic" value="Mari ASSR" data-val="Mari ASSR"> Mari ASSR</label>
              <label><input type="checkbox" name="republic" value="Tartar ASSR" data-val="Tartar ASSR"> Tartar ASSR</label>
              <label><input type="checkbox" name="republic" value="Tuvan ASSR" data-val="Tuvan ASSR"> Tuvan ASSR</label>
              <label><input type="checkbox" name="republic" value="Other" data-val="Other"> Other</label>
            </div>
          
                <div class="filter-actions">
                   <button class="small-action select-all">Select all</button>
                   <button class="small-action clear-all">Clear all</button>
                 </div>
          </div>

          <!-- DECADE -->
          <div class="filter-group" data-group="decade">
            <div class="filter-header">
              <h4>Decade</h4>
              <div class="filter-actions"></div>
            </div>
            <div class="filter-options" id="filter-decade">
              <label><input type="checkbox" name="decade" value="1920s" data-val="1920s"> 1920s</label>
              <label><input type="checkbox" name="decade" value="1930s" data-val="1930s"> 1930s</label>
              <label><input type="checkbox" name="decade" value="1940s" data-val="1940s"> 1940s</label>
              <label><input type="checkbox" name="decade" value="1950s" data-val="1950s"> 1950s</label>
              <label><input type="checkbox" name="decade" value="1960s" data-val="1960s"> 1960s</label>
              <label><input type="checkbox" name="decade" value="1970s" data-val="1970s"> 1970s</label>
              <label><input type="checkbox" name="decade" value="1980s" data-val="1980s"> 1980s</label>
            </div>
                 <div class="filter-actions">
                   <button class="small-action select-all">Select all</button>
                   <button class="small-action clear-all">Clear all</button>
                 </div>
          </div>

          <!-- GENDER -->
          <div class="filter-group" data-group="gender">
            <div class="filter-header">
              <h4>Gender</h4>
              <div class="filter-actions"></div>
            </div>
            <div class="filter-options" id="filter-gender">
              <label><input type="checkbox" name="gender" value="Male" data-val="Male"> Male</label>
              <label><input type="checkbox" name="gender" value="Female" data-val="Female"> Female</label>
              <label><input type="checkbox" name="gender" value="Other" data-val="Other"> Other</label>
            </div>
                 <div class="filter-actions">
                   <button class="small-action select-all">Select all</button>
                   <button class="small-action clear-all">Clear all</button>
                 </div>
          </div>

          <!-- TYPE -->
          <div class="filter-group" data-group="type">
            <div class="filter-header">
              <h4>Type of Piece</h4>
              <div class="filter-actions"></div>
            </div>
            <div class="filter-options" id="filter-type">
              <label><input type="checkbox" name="type" value="Concert Piece" data-val="Concert Piece"> Concert Piece</label>
              <label><input type="checkbox" name="type" value="Concerto/Concertino" data-val="Concerto/Concertino"> Concerto/Concertino</label>
              <label><input type="checkbox" name="type" value="Fantasy/Variations" data-val="Fantasy/Variations"> Fantasy/Variations</label>
              <label><input type="checkbox" name="type" value="Poem" data-val="Poem"> Poem</label>
              <label><input type="checkbox" name="type" value="Scherzo" data-val="Scherzo"> Scherzo</label>
              <label><input type="checkbox" name="type" value="Sonata/Sonatina" data-val="Sonata/Sonatina"> Sonata/Sonatina</label>
            </div>
                 <div class="filter-actions">
                   <button class="small-action select-all">Select all</button>
                   <button class="small-action clear-all">Clear all</button>
                 </div>
          </div>

        </div>
      </aside>
  <div class="panel" id="panel-center">
        <h3 class="panel-title">Results</h3>
        <div class="panel-divider"></div>

        <div id="results-list">
          <!-- Result Card Template: client will replace placeholders with actual data -->
          <div class="result-card">
            <div class="result-main">
              <b>[A]</b>
              <div class="meta">[J] ([K])</div>
            </div>
            <div class="result-right">
              <button type="button" class="about-label">About this composer</button>
              <button class="more-composer-btn">More from this composer</button>
            </div>
          </div>

          <div class="result-card">
            <div class="result-main">
              <b>[A]</b>
              <div class="meta">[J] ([K])</div>
            </div>
            <div class="result-right">
              <div class="about-label" aria-hidden="true">About this composer</div>
              <button class="more-composer-btn">More from this composer</button>
            </div>
          </div>

          <div class="result-card">
            <div class="result-main">
              <b>[A]</b>
              <div class="meta">[J] ([K])</div>
            </div>
            <div class="result-right">
              <div class="about-label" aria-hidden="true">About this composer</div>
              <button class="more-composer-btn">More from this composer</button>
            </div>
          </div>
        </div>

        <!-- Pagination (static template; client may replace this) -->
        <div class="pagination" style="margin-top:12px;">
          <button class="page-btn page-arrow">&lt;</button>
          <button class="page-btn" aria-current="true">1</button>
          <button class="page-btn">2</button>
          <button class="page-btn">3</button>
          <span class="page-ellipsis">…</span>
          <button class="page-btn">10</button>
          <button class="page-btn page-arrow">&gt;</button>
        </div>
      </div>
      <div class="panel" id="panel-right">
        <h3 class="panel-title">Composer information</h3>
        <div class="panel-divider"></div>
        <div id="composer-content" style="margin-top:8px">Select a result to view composer details.</div>
        <!-- Dedicated container for "More from this composer" so the client can toggle it
             without being overwritten when #composer-content is replaced. -->
        <div id="more-from-composer" style="margin-top:16px; display:none;"></div>
        <div style="margin-top:12px;">
          <button id="clear-composer" style="display:none;padding:6px 10px;border-radius:6px;border:1px solid #d1d5db;background:#fff;">Clear composer</button>
        </div>
      </div>
    </div>
    <!-- background overlay (moved to page top) -->

    <!-- Background adjustment control removed -->

    <!-- duplicate bottom search bar removed -->

    <!-- main content is now presented inside the three panels above -->

  <div id="fixed-footer" aria-hidden="false" role="contentinfo" tabindex="0" style="display:block; visibility:visible; z-index:99999; background:#8b0000; color:#fff;">
    <div class="fixed-footer-inner" style="max-width:1100px; margin:0 auto; padding:8px 20px; display:flex; justify-content:space-between; align-items:center;">
      <div class="footer-left">
        <div class="title">Archive of Soviet Trumpet Music</div>
        <div class="subtitle">Архив советской трубной музыки</div>
      </div>
      <div class="fixed-footer-center">
        <div class="links">
          <a href="/about">About</a>
          <a href="/composers">Composers</a>
        </div>
      </div>
      <div class="fixed-footer-right">
        <div class="copyright">© 2025 Archive of Soviet Trumpet Music</div>
      </div>
    </div>
  </div>

    <!-- Mobile toolbar: Filters | Hamburger menu (center) | Sources -->
    <div class="mobile-footer-toolbar" id="mobileFooterToolbar" aria-hidden="false">
      <button class="mf-btn" id="mf-filters">Filters</button>
      <button class="mf-center" id="mf-hamburger" aria-label="Menu" aria-expanded="false">☰</button>
  <!-- composers button removed -->
    </div>

    <!-- Left-edge swipe menu overlay (sliding panel) -->
    <div id="mobile-swipe-menu" class="mobile-swipe-menu" aria-hidden="true">
      <div class="swipe-inner" role="menu" aria-label="Quick menu">
        <button id="swm-close" class="swm-close">Close</button>
        <div style="padding:12px">
          <button id="swm-about" class="swm-item">About</button>
          <button id="swm-composers" class="swm-item">Composers</button>
          <button id="swm-home" class="swm-item">Home</button>
        </div>
      </div>
    </div>

    <script>
      // Mobile overlay helpers: lock body scroll and allow independent scrolling in overlay panels.
      (function(){
        var quickMenu = document.getElementById('mobile-swipe-menu');
        var quickClose = document.getElementById('swm-close');
        var mfFiltersBtn = document.getElementById('mf-filters');

        function lockBody(){ try{ document.documentElement.style.overflow = 'hidden'; document.body.style.overflow = 'hidden'; }catch(_){ } }
        function unlockBody(){ try{ document.documentElement.style.overflow = ''; document.body.style.overflow = ''; }catch(_){ } }

        // Quick menu open/close
        function openQuickMenu(){ if (!quickMenu) return; quickMenu.setAttribute('aria-hidden','false'); var si = quickMenu.querySelector('.swipe-inner'); try{ si && si.focus && si.focus(); }catch(_){ } lockBody(); }
        function closeQuickMenu(){ if (!quickMenu) return; quickMenu.setAttribute('aria-hidden','true'); unlockBody(); }

        try{ if (quickClose) quickClose.addEventListener('click', function(e){ e && e.preventDefault && e.preventDefault(); closeQuickMenu(); }); }catch(_){ }
        try{ quickMenu && quickMenu.addEventListener('click', function(e){ if (e.target === quickMenu) closeQuickMenu(); }); }catch(_){ }

        // Filter overlay (clones #panel-left into a mobile-friendly overlay)
        function openFilterOverlay(){
          // if already open, do nothing
          if (document.getElementById('mobile-filter-overlay')) return;
          var left = document.getElementById('panel-left');
          if (!left) return;
          var overlay = document.createElement('div'); overlay.id = 'mobile-filter-overlay'; overlay.className = 'mobile-swipe-menu'; overlay.setAttribute('aria-hidden','false');
          var inner = document.createElement('div'); inner.className = 'swipe-inner'; inner.setAttribute('role','menu'); inner.setAttribute('aria-label','Filters');
          // add a close control
          var close = document.createElement('button'); close.className = 'swm-close'; close.textContent = 'Close'; close.addEventListener('click', function(e){ e && e.preventDefault && e.preventDefault(); closeFilterOverlay(); });
          inner.appendChild(close);
          // ensure inner is sized and scrollable on mobile
          try{
            inner.style.overflow = 'auto';
            inner.style.height = 'calc(100vh - 120px)'; // account for topbar (64px) + footer toolbar (56px)
            inner.style.webkitOverflowScrolling = 'touch';
            // make overlay explicitly fixed/inset so it sits above the page and doesn't alter layout
            try{ overlay.style.position = 'fixed'; overlay.style.inset = '0'; overlay.style.background = 'rgba(0,0,0,0.45)'; }catch(_){ }
            // size the inner panel to match mobileSidePanel behavior (right-side panel)
            try{ inner.style.position = 'absolute'; inner.style.top = '64px'; inner.style.bottom = '56px'; inner.style.right = '0'; inner.style.left = 'auto'; inner.style.width = 'calc(100vw - 60px)'; inner.style.maxWidth = '92%'; inner.style.boxSizing = 'border-box'; inner.style.borderRadius = '8px 0 0 8px'; }catch(_){ }
          }catch(_){ }
          // remove any right-side mobile overlays so they don't cover the filter overlay
          try{ document.querySelectorAll('.mobile-overlay.right').forEach(function(el){ try{ el.remove(); }catch(_){ } }); }catch(_){ }
          // clone the panel-left content
          try{
            var clone = left.cloneNode(true);
            clone.id = 'panel-left-mobile-clone'; clone.classList.add('mobile-overlay-clone'); clone.style.margin = '0'; clone.style.width = '100%';
            // ensure clone is positioned relative inside the overlay and can scroll
            clone.style.position = 'relative';
            try{ clone.style.overflow = 'auto'; clone.style.maxHeight = '100%'; clone.style.height = '100%'; }catch(_){ }
            inner.appendChild(clone);
            // Ensure the inner filter-box inside the clone is positioned and scrollable
            try{
              var fb = clone.querySelector && clone.querySelector('.filter-box');
              if (fb){
                fb.style.position = 'absolute';
                fb.style.top = '60px'; // matches header + small offset — adjust if needed
                fb.style.bottom = '0';
                fb.style.left = '0';
                fb.style.right = '0';
                fb.style.overflowY = 'auto';
                fb.style.webkitOverflowScrolling = 'touch';
                fb.style.padding = '0 16px';
                fb.style.boxSizing = 'border-box';
              }
            }catch(_){ }
          }catch(_){
            // Do NOT move the original node out of the main layout. Instead copy its markup
            try{
              var fallbackClone = document.createElement('div');
              fallbackClone.id = 'panel-left-mobile-clone';
              fallbackClone.classList.add('mobile-overlay-clone');
              fallbackClone.style.margin = '0';
              fallbackClone.style.width = '100%';
              fallbackClone.style.position = 'static';
              fallbackClone.style.overflow = 'auto';
              fallbackClone.style.maxHeight = '100%';
              fallbackClone.innerHTML = left.innerHTML || '';
              inner.appendChild(fallbackClone);
              // Apply same portable styles to the fallback clone's .filter-box so it scrolls
              try{
                var fb2 = fallbackClone.querySelector && fallbackClone.querySelector('.filter-box');
                if (fb2){
                  fb2.style.position = 'absolute';
                  fb2.style.top = '60px';
                  fb2.style.bottom = '0';
                  fb2.style.left = '0';
                  fb2.style.right = '0';
                  fb2.style.overflowY = 'auto';
                  fb2.style.webkitOverflowScrolling = 'touch';
                  fb2.style.padding = '0 16px';
                  fb2.style.boxSizing = 'border-box';
                }
              }catch(_){ }
            }catch(_2){
              try{ var ph = document.createElement('div'); ph.textContent = 'Filters'; inner.appendChild(ph); }catch(_3){}
            }
          }
          // ensure overlay sits above other fixed UI (header/footer)
          try{ overlay.style.zIndex = '100000'; overlay.style.pointerEvents = 'auto'; }catch(_){ }
          try{ inner.style.zIndex = '100001'; }catch(_){ }
          overlay.appendChild(inner);
          document.body.appendChild(overlay);
          // mark that a filter overlay is active so other overlay creators
          // (right-side composer overlays) can avoid creating competing panels
          try{ window.__mobileOverlayLock = 'filters'; }catch(_){ }
          // Robust body scroll lock: store scroll position and fix body to viewport
          try{
            var _savedScrollY = window.scrollY || document.documentElement.scrollTop || 0;
            // store on overlay so close can restore
            overlay.__savedScrollY = _savedScrollY;
            // apply fixed positioning to body to prevent background scroll while allowing overlay inner to scroll
            document.body.style.position = 'fixed';
            document.body.style.top = '-' + _savedScrollY + 'px';
            document.body.style.left = '0';
            document.body.style.right = '0';
            document.body.style.width = '100%';
            // also set overflow hidden as a fallback
            document.documentElement.style.overflow = 'hidden';
            document.body.style.overflow = 'hidden';
          }catch(_){ try{ lockBody(); }catch(__){} }
          // focus the inner area for accessibility
          try{ inner.focus && inner.focus(); }catch(_){ }
          // closing by tapping backdrop
          overlay.addEventListener('click', function(e){ if (e.target === overlay) closeFilterOverlay(); });
        }
    function closeFilterOverlay(){ var ov = document.getElementById('mobile-filter-overlay'); if (!ov) return; 
        try{
          // restore scroll position if we saved one
          var saved = ov.__savedScrollY || 0;
          ov.remove();
          // clear lock
          try{ if (window.__mobileOverlayLock === 'filters') window.__mobileOverlayLock = null; }catch(_){ }
          // restore body positioning and scroll
          try{
            // remove fixed positioning
            document.body.style.position = '';
            var top = document.body.style.top || '';
            document.body.style.top = '';
            document.body.style.left = '';
            document.body.style.right = '';
            document.body.style.width = '';
            // clear overflow overrides
            document.documentElement.style.overflow = '';
            document.body.style.overflow = '';
            // scroll back to where we were
            if (saved) { window.scrollTo(0, saved); }
          }catch(_){ try{ unlockBody(); }catch(__){} }
        }catch(e){ try{ ov.remove(); }catch(_){ } try{ unlockBody(); }catch(__){} }
      }

    try{ if (mfFiltersBtn) mfFiltersBtn.addEventListener('click', function(e){ e && e.preventDefault && e.preventDefault();
      try{ if (window.__mobileOverlayLock === 'filters') return; }catch(_){ }
      try{ if (document.querySelector('.mobile-overlay.left') || document.querySelector('.mobile-swipe-menu') || document.getElementById('mobile-filter-overlay')) return; }catch(_){ }
      openFilterOverlay();
    }); }catch(_){ }

        // Prevent touchmove on document when an overlay is open; allow it when the
        // touchstart/target is inside a known scrollable overlay region so that
        // inner panels (filters, composer panel, cloned overlays) can scroll.
        document.addEventListener('touchmove', function(e){
          var qmOpen = quickMenu && quickMenu.getAttribute('aria-hidden') === 'false';
          var fo = document.getElementById('mobile-filter-overlay'); var foOpen = !!fo;
          // If no overlays we care about are present, don't intervene
          if (!qmOpen && !foOpen && !document.querySelector('.mobile-overlay') && !document.getElementById('mobileSidePanel')) return;
          var allow = false;
          try{
            var target = e.target;
            if (target){
              // allow inside the quick-menu swipe-inner
              if (qmOpen){ var si = quickMenu.querySelector('.swipe-inner'); if (si && si.contains(target)) allow = true; }
              // allow inside the filter-overlay swipe-inner (our cloned filter panel)
              if (!allow && foOpen){ var si2 = fo.querySelector('.swipe-inner'); if (si2 && si2.contains(target)) allow = true; }
              // allow inside common overlay inner containers (right panels, generic overlays)
              if (!allow){
                var nodes = document.querySelectorAll('.swipe-inner, .overlay-inner, .overlay-right-inner, .mobile-overlay-clone, #mobileSidePanel');
                for (var i=0;i<nodes.length && !allow;i++){ try{ if (nodes[i] && nodes[i].contains(target)) allow = true; }catch(_){ } }
              }
            }
          }catch(_){ }
          if (!allow){ e.preventDefault && e.preventDefault(); }
        }, { passive: false });

      })();
    </script>

  <!--
    Client runtime (heavy): /public/composers-results.client.js
    - This external script performs data fetching (/api/sheets), normalization,
      filtering, pagination, and renders the center panel items dynamically.
    - If you need to change client-side rendering logic for the center panel
      or the card layout, edit the client script (public/composers-results.client.js)
      NOT the server page. The client script will insert nodes matching the
      .result-card/.result-main/.result-right structure defined above.
  -->
  <script>
    // Defensive shim: ensure a callable openComposerFromName exists before the heavy client loads.
    // This lets static buttons immediately open a mobile overlay (fallback) so clicks don't appear to do nothing.
    (function(){
      try{
        if (window && typeof window.openComposerFromName !== 'function'){
          window.openComposerFromName = function(name, row){
            try{
              window.selectedComposer = String(name || '');
              // populate a minimal composer-content if present
              var content = document.getElementById('composer-content');
              if (content) {
                content.textContent = String(name || '');
              }
              // If small screen, clone/right-panel into a mobile overlay similar to client behavior
              if (window.innerWidth <= 600){
                // if a filter overlay is active, don't create an additional right overlay
                try{ if (window.__mobileOverlayLock === 'filters') return true; }catch(_){ }
                // remove any open filter overlay so the right-side panel is not behind it
                try{ var fo = document.getElementById('mobile-filter-overlay'); if (fo) fo.remove(); }catch(_){ }
                if (!document.querySelector('.mobile-overlay.right')){
                  var overlay = document.createElement('div');
                  overlay.className = 'mobile-overlay right';
                  overlay.setAttribute('role','dialog'); overlay.setAttribute('aria-modal','true');
                  overlay.style.position = 'fixed'; overlay.style.inset = '0'; overlay.style.zIndex = '1990'; overlay.style.background = 'rgba(0,0,0,0.18)';
                  var inner = document.createElement('div');
                  inner.className = 'overlay-inner overlay-right-inner';
                  inner.style.position = 'absolute'; inner.style.top = '0'; inner.style.bottom = '0'; inner.style.right = '0'; inner.style.left = 'auto';
                  inner.style.width = 'min(92%, 420px)'; inner.style.maxWidth = '420px'; inner.style.zIndex = '1995'; inner.style.background = 'white'; inner.style.boxSizing = 'border-box'; inner.style.padding = '16px';
                  // clone the right panel if present
                  var panel = document.getElementById('panel-right');
                  if (panel){
                    var clone = panel.cloneNode(true);
                    clone.id = 'panel-right-mobile-clone'; clone.classList.add('mobile-overlay-clone'); clone.style.margin = '0'; clone.style.padding = '0'; clone.style.width = '100%';
                    try{ clone.style.position = 'relative'; clone.style.overflow = 'auto'; clone.style.maxHeight = '100%'; clone.style.height = '100%'; }catch(_){ }
                    inner.appendChild(clone);
                    try{ var fb = clone.querySelector && clone.querySelector('.filter-box'); if (fb){ fb.style.overflowY = 'auto'; fb.style.webkitOverflowScrolling = 'touch'; } }catch(_){ }
                  } else {
                    inner.innerHTML = '<div style="padding:12px">Composer</div>';
                  }
                  overlay.appendChild(inner);
                  document.body.appendChild(overlay);
                  // lock body when this right-side overlay is open so inner scroll works
                  try{ window.__mobileOverlayLock = 'composer'; var _s = window.scrollY || document.documentElement.scrollTop || 0; overlay.__savedScrollY = _s; document.body.style.position = 'fixed'; document.body.style.top = '-' + _s + 'px'; document.body.style.left = '0'; document.body.style.right = '0'; document.body.style.width = '100%'; document.documentElement.style.overflow = 'hidden'; document.body.style.overflow = 'hidden'; }catch(_){ try{ document.body.style.overflow = 'hidden'; document.documentElement.style.overflow = 'hidden'; }catch(__){} }
                  overlay.addEventListener('click', function(ev){ if (ev.target === overlay) overlay.remove(); });
                }
              } else {
                var elp = document.getElementById('panel-right'); if (elp) elp.scrollIntoView({behavior:'smooth', block:'center'});
              }
              return true;
            }catch(e){ return false; }
          };
        }
      }catch(e){ /* ignore */ }
    })();
  </script>
  <script src="/composers-results.client.js?v=3" defer></script>
   <!-- Bridge script (below) provides a small shim for static buttons to call
         client-side filter functions. We intentionally disable composer filtering
         here per product decision; keep a safe no-op to avoid runtime errors. -->
   <script>
    // Safe no-op bridge for static template buttons. Avoids triggering client-side
    // filtering by composer while preserving the global API shape.
    window.filterByComposer = function(name){
      try{ console.log('[bridge] filterByComposer called but no-op:', name); }catch(_){ }
      // intentionally do not set window.selectedComposer or call loadResults()
    };
  </script>

    <!-- background overlay (behind everything) -->
    <div id="bg-overlay" aria-hidden="true">
      <img id="bg-img" src="https://i.imgur.com/ZENogwV.png" alt="" />
    </div>
    <script>
    // Select All / Clear All for filter groups — dispatches change events and triggers loadResults
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.filter-group').forEach(group => {
        const selectAll = group.querySelector('.select-all');
        const clearAll = group.querySelector('.clear-all');
        const checks = Array.from(group.querySelectorAll('input[type="checkbox"]'));
        const dispatchChange = (el) => { try{ const ev = new Event('change', { bubbles: true }); el.dispatchEvent(ev); }catch(_){ try{ const ev2 = document.createEvent('HTMLEvents'); ev2.initEvent('change', true, false); el.dispatchEvent(ev2); }catch(_){}} };
        const applyAndNotify = (val) => { checks.forEach(c => { c.checked = val; dispatchChange(c); }); try{ if (window && typeof window.loadResults === 'function'){ window.currentPage = 1; window.loadResults(); } }catch(_){ } };
        if (selectAll) selectAll.addEventListener('click', (e) => { e.preventDefault(); applyAndNotify(true); });
        if (clearAll) clearAll.addEventListener('click', (e) => { e.preventDefault(); applyAndNotify(false); });
      });
    });
    </script>
    <script>
    // General-purpose, clone-aware checkbox syncing and DOM fallback filtering.
    // Prefers the mobile clone (#panel-left-mobile-clone) when present, falls back to #panel-left.
    document.addEventListener('DOMContentLoaded', ()=>{
      function getChecked(selector) {
        try {
          const base = document.querySelector('#panel-left-mobile-clone') || document.querySelector('#panel-left');
          if (!base) return [];

          return Array.from(base.querySelectorAll(selector + ' input[type=checkbox]:checked'))
            .map(cb => {
              try {
                // Prefer explicit data attributes (data-val or data-value) when available.
                const dataVal = cb.dataset && cb.dataset.val ? cb.dataset.val : (cb.getAttribute && (cb.getAttribute('data-val') || cb.getAttribute('data-value')));
                // If no data attribute, attempt to read nearby label text (supports <label><input/>Text</label>)
                let labelText = '';
                try {
                  const lbl = cb.closest && cb.closest('label');
                  if (lbl && lbl.textContent) labelText = lbl.textContent;
                  else if (cb.nextSibling && cb.nextSibling.textContent) labelText = cb.nextSibling.textContent;
                  else if (cb.parentElement && cb.parentElement.tagName === 'LABEL' && cb.parentElement.textContent) labelText = cb.parentElement.textContent;
                } catch (_){ /* ignore */ }

                const raw = dataVal || labelText || cb.value || '';
                // decode only when it appears encoded; decodeURIComponent is safe on plain strings here
                try { return decodeURIComponent(String(raw)).trim(); } catch(_) { return String(raw).trim(); }
              } catch (_){ return ''; }
            })
            .map(s => (s || '').trim())
            .filter(Boolean);
        } catch (e) { return []; }
      }

      function cardMatches(card, q, countries, decades, types, genders, republics){
        try{
          const txt = (card.textContent || '').toLowerCase();
          if (q && !txt.includes(q)) return false;
          const anyMatch = (list) => { if (!list || !list.length) return true; return list.some(v => txt.includes(String(v||'').toLowerCase())); };
          return anyMatch(countries) && anyMatch(decades) && anyMatch(types) && anyMatch(genders) && anyMatch(republics);
        }catch(e){ return true; }
      }

      function filterResults(){
        try{
          // If the heavy client runtime is present, prefer it (it will fetch /api/sheets etc.)
          if (typeof window.loadResults === 'function'){
            try{ window.currentPage = 1; window.loadResults(); return; }catch(_){ }
          }

          const countries = getChecked('#filter-country');
          const republics = getChecked('#filter-republic');
          const decades = getChecked('#filter-decade');
          const types = getChecked('#filter-type');
          const genders = getChecked('#filter-gender');
          const q = document.querySelector('#qinput')?.value?.toLowerCase() || '';

          document.querySelectorAll('.result-card').forEach(card => {
            if (cardMatches(card, q, countries, decades, types, genders, republics)) {
              card.style.display = '';
            } else {
              card.style.display = 'none';
            }
          });
        }catch(e){ console.warn('filterResults failed', e); }
      }

      function syncCheckboxes(){
        try{
          function bindAll(){
            const desktop = document.querySelector('#panel-left');
            const mobile = document.querySelector('#panel-left-mobile-clone');
            if (!desktop && !mobile) return;
            const desktopBoxes = desktop ? Array.from(desktop.querySelectorAll('input[type=checkbox]')) : [];
            const mobileBoxes = mobile ? Array.from(mobile.querySelectorAll('input[type=checkbox]')) : [];
            const allCheckboxes = desktopBoxes.concat(mobileBoxes);

            allCheckboxes.forEach(cb => {
              if (cb.__synced) return; // avoid double-binding
              cb.__synced = true;
              cb.addEventListener('change', () => {
                try{
                  const name = cb.name;
                  const value = cb.value;
                  const checked = cb.checked;
                  // find counterpart in the other panel
                  const isDesktop = !!cb.closest('#panel-left');
                  const targetPanel = isDesktop ? document.querySelector('#panel-left-mobile-clone') || document.querySelector('#panel-left') : document.querySelector('#panel-left') || document.querySelector('#panel-left-mobile-clone');
                  if (targetPanel){
                    const candidates = Array.from(targetPanel.querySelectorAll(`input[name="${name}"]`));
                    for (let i=0;i<candidates.length;i++){
                      if (String(candidates[i].value) === String(value) && candidates[i] !== cb){
                        candidates[i].checked = checked;
                        try{ candidates[i].dispatchEvent(new Event('change', { bubbles: true })); }catch(_){ }
                        break;
                      }
                    }
                  }
                }catch(_){ }
                // run the filter after every change
                filterResults();
              });
            });
          }

          bindAll();
          // watch for the mobile clone being added/removed and re-bind
          try{
            const mo = new MutationObserver((mutations)=>{
              for (const m of mutations){
                for (const n of Array.from(m.addedNodes || [])){
                  if (n && n.id === 'panel-left-mobile-clone') { bindAll(); filterResults(); return; }
                }
              }
            });
            mo.observe(document.body, { childList: true, subtree: true });
          }catch(_){ }
        }catch(e){ }
      }

      // Wire search input
      try{ document.querySelector('#qinput')?.addEventListener('input', filterResults); }catch(_){ }

      // Initialize syncing and an initial filter pass
      syncCheckboxes();
      setTimeout(filterResults, 50);
    });
    </script>
    <script>
    // Mobile-only: open an empty right-side panel when a result card is clicked.
    // This is intentionally visual-only: it creates a sliding panel from the right
    // on small screens (<=600px) and provides a close button.
    (function(){
      function openEmptyRightPanel(){
        if (document.querySelector('.mobile-overlay.right')) return;
        var overlay = document.createElement('div');
        overlay.className = 'mobile-overlay right';
        overlay.setAttribute('role','dialog'); overlay.setAttribute('aria-modal','true');
        overlay.style.position = 'fixed'; overlay.style.inset = '0'; overlay.style.zIndex = '1990'; overlay.style.background = 'rgba(0,0,0,0.18)';
        var inner = document.createElement('div');
        inner.className = 'overlay-inner overlay-right-inner';
        inner.style.position = 'absolute'; inner.style.top = '0'; inner.style.bottom = '0'; inner.style.right = '0'; inner.style.left = 'auto';
        inner.style.width = 'min(92%, 420px)'; inner.style.maxWidth = '420px'; inner.style.zIndex = '1995'; inner.style.background = 'white'; inner.style.boxSizing = 'border-box'; inner.style.padding = '12px';
        // header with close
        var header = document.createElement('div'); header.style.display = 'flex'; header.style.alignItems = 'center'; header.style.justifyContent = 'space-between';
        var title = document.createElement('div'); title.textContent = '';
        var closeBtn = document.createElement('button'); closeBtn.type = 'button'; closeBtn.innerHTML = '✕'; closeBtn.style.border = '0'; closeBtn.style.background = 'transparent'; closeBtn.style.fontSize = '1.1rem'; closeBtn.style.cursor = 'pointer';
        closeBtn.addEventListener('click', function(){ try{ overlay.remove(); }catch(_){} });
        header.appendChild(title); header.appendChild(closeBtn);
        inner.appendChild(header);
        // empty body area
        var body = document.createElement('div'); body.style.minHeight = '40vh'; body.style.color = '#111'; inner.appendChild(body);
        overlay.appendChild(inner);
        document.body.appendChild(overlay);
        overlay.addEventListener('click', function(ev){ if (ev.target === overlay) overlay.remove(); });
      }

      document.addEventListener('click', function delegatedAboutClick(ev){
        try{
          // Only trigger when the click is inside the small 'about' control
          var about = ev.target && ev.target.closest ? ev.target.closest('.about-label, .about-badge') : null;
          if (!about) return;
          if (window.innerWidth > 600) return; // only on mobile
          ev.preventDefault && ev.preventDefault(); ev.stopPropagation && ev.stopPropagation();
          // Try to discover the composer name from nearby DOM.
          var composerName = '';
          try{
            var card = about.closest ? about.closest('.result-card') : null;
            if (card){
              var link = card.querySelector('.composer-link[data-name]') || card.querySelector('.composer-link');
              if (link) composerName = (link.getAttribute && link.getAttribute('data-name')) || (link.textContent && link.textContent.trim()) || '';
            }
            // If not found in a result-card (React list), look for the composer-group heading
            if (!composerName){
              var group = about.closest ? about.closest('.composer-group') : null;
              if (group){
                var h = group.querySelector('h3'); if (h && h.textContent) composerName = h.textContent.trim();
              }
            }
          }catch(_){ composerName = ''; }

          // Prefer using the client helper if present so it populates real content.
          if (composerName && window && typeof window.openComposerFromName === 'function'){
            try{
              var ok = window.openComposerFromName(composerName);
              if (ok) return; // helper handled it
            }catch(_){ }
          }
          // Fallback: open the empty overlay
          openEmptyRightPanel();
        }catch(_){ }
      }, { capture: false });
    })();
    </script>
    
    <!-- Hydrate the React ComposersPage client-side for debugging and to enable client-only behavior -->
    <div id="composers-client-mount" style="display:none; visibility:hidden; width:0; height:0; overflow:hidden;">
      <!-- This intentionally hydrates the React component offscreen so its useEffects run -->
      <ComposersPage client:load />
    </div>
    
      <!-- Mobile side panel markup (moved from composers.astro) -->
  <div id="mobileSidePanel" aria-hidden="true" role="region" style="display:none">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700;color:var(--accent)">Composer details</div>
          <button id="closePanelBtn" aria-label="Close" style="border:0;background:transparent;font-size:18px;cursor:pointer;">✕</button>
        </div>
        <div id="mobilePanelContent" style="margin-top:12px">Select a composer to view details.</div>
      </div>


  // === MOBILE COMPOSER PANEL LOGIC ===
 <script>
(function(){
  var _panelLeftPrevDisplay = null;
  var _filterBtnPrevDisabled = null;

  function showPanel(){
    try{
      var p = document.getElementById('mobileSidePanel'); if(!p) return;
      try{
        var left = document.getElementById('panel-left');
        if (left){ _panelLeftPrevDisplay = left.style.display || ''; left.style.display = 'none'; }
      }catch(_){}
      try{
        var fbtn = document.getElementById('mf-filters');
        if (fbtn){ _filterBtnPrevDisabled = !!fbtn.disabled; fbtn.disabled = true; fbtn.setAttribute('aria-disabled','true'); fbtn.classList && fbtn.classList.add('disabled'); }
      }catch(_){}
      try{ var sm = document.getElementById('mobile-swipe-menu'); if (sm && sm.getAttribute('aria-hidden') === 'false'){ sm.setAttribute('aria-hidden','true'); } }catch(_){}
      p.style.display = 'block';
      try{
        // prefer inert when available to remove from accessibility tree for siblings
        if ('inert' in p) p.inert = false;
      }catch(_){ }
      try{ p.setAttribute('aria-hidden','false'); }catch(_){}
      // focus the close button after rendering so screen readers land inside the panel
      setTimeout(function(){ try{ var closeBtn = document.getElementById('closePanelBtn'); if (closeBtn && typeof closeBtn.focus === 'function'){ closeBtn.focus({ preventScroll: true }); } }catch(_){ } }, 20);
      try{ document.body.classList.add('no-scroll'); document.documentElement.classList.add('no-scroll'); }catch(_){}
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }catch(e){console.warn(e)}
  }

  function hidePanel(){
    try{
      var p = document.getElementById('mobileSidePanel'); if(!p) return;
      try{
        var tbtn = document.getElementById('togglePanelBtn');
        if (tbtn && typeof tbtn.focus === 'function'){
          tbtn.focus({ preventScroll: true });
        }
      }catch(_){}
      // If any element inside the panel still has focus, move or blur focus first
      try{
        var active = document.activeElement;
        if (active && p.contains(active)){
          try{
            var targetFocus = document.getElementById('togglePanelBtn') || document.getElementById('closePanelBtn');
            if (targetFocus && typeof targetFocus.focus === 'function'){
              targetFocus.focus({ preventScroll: true });
            } else {
              try{ active.blur && active.blur(); }catch(_){ }
            }
          }catch(_){ try{ active.blur && active.blur(); }catch(__){} }
        }
      }catch(_){ }
      // Defer applying aria-hidden/inert to ensure focus change is processed by assistive tech
      setTimeout(function(){
        try{ if ('inert' in p) p.inert = true; }catch(_){ }
        try{ p.setAttribute('aria-hidden','true'); }catch(_){}
        try{ p.style.display = 'none'; }catch(_){ }
      }, 0);
      try{ document.body.classList.remove('no-scroll'); document.documentElement.classList.remove('no-scroll'); }catch(_){}
      try{ var left = document.getElementById('panel-left'); if (left && _panelLeftPrevDisplay !== null){ left.style.display = _panelLeftPrevDisplay || ''; _panelLeftPrevDisplay = null; } }catch(_){}
      try{ var fbtn = document.getElementById('mf-filters'); if (fbtn && _filterBtnPrevDisabled !== null){ fbtn.disabled = !!_filterBtnPrevDisabled; if (!fbtn.disabled) fbtn.removeAttribute('aria-disabled'); else fbtn.setAttribute('aria-disabled','true'); fbtn.classList && fbtn.classList.remove('disabled'); _filterBtnPrevDisabled = null; } }catch(_){}
    }catch(e){}
  }

  function populateAndShowFromCard(card){
    try{
      if(!card) return;
      var main = card.querySelector('.result-main');
      var title = '';
      try{ var b = main && main.querySelector('b'); if(b) title = (b.textContent || '').trim(); }catch(_){ }

      function setMobileLoading(){
        try{
          var mobile = document.getElementById('mobilePanelContent');
          if (!mobile) return;
          mobile.innerHTML = '<div style="padding:12px">Loading composer details...</div>';
        }catch(_){}
      }

      var helperTried = false;
      if (title && window && typeof window.openComposerFromName === 'function'){
        helperTried = true;
        try{
          var ok = window.openComposerFromName(title, card);
          if (ok){
            setMobileLoading();
            var onPop = function(e){
              try{
                var mobile = document.getElementById('mobilePanelContent');
                if (mobile && e && e.detail && e.detail.html){
                  mobile.innerHTML = e.detail.html;
                }
              }catch(_){}
              document.removeEventListener('composerPopulated', onPop);
            };
            document.addEventListener('composerPopulated', onPop);
            showPanel();
            return;
          }
        }catch(_){}
      }

      if (!helperTried && title && window && typeof window.populateComposerBox === 'function'){
        try{
          setMobileLoading();
          var onPop2 = function(e){
            try{ var mobile = document.getElementById('mobilePanelContent'); if (mobile && e && e.detail && e.detail.html) mobile.innerHTML = e.detail.html; }catch(_){}
            document.removeEventListener('composerPopulated', onPop2);
          };
          document.addEventListener('composerPopulated', onPop2);
          window.populateComposerBox(title, card);
          showPanel();
          return;
        }catch(_){}
      }

      setMobileLoading();
      showPanel();
    }catch(e){ console.warn('populateFromCard failed', e); }
  }

  document.addEventListener('DOMContentLoaded', function(){
    // ===== Store all cards once on page load =====
    const allCards = Array.from(document.querySelectorAll('.result-card'));
    console.log('All cards stored:', allCards.length);

    // ===== Filter checkboxes =====
    const filterCheckboxes = document.querySelectorAll('.filter-checkbox');
    filterCheckboxes.forEach(cb => {
      cb.addEventListener('change', applyFilters);
    });

    function applyFilters() {
      const activeFilters = Array.from(filterCheckboxes)
        .filter(cb => cb.checked)
        .map(cb => cb.value);
      console.log('Active filters:', activeFilters);

      allCards.forEach(card => {
        const cardCountry = card.dataset.country;
        const showByCountry = activeFilters.length === 0 || activeFilters.includes(cardCountry);
        card.style.display = showByCountry ? '' : 'none';
      });
    }

    // ===== Mobile panel toggle buttons =====
    const t = document.getElementById('togglePanelBtn');
    if(t) t.addEventListener('click', function(ev){ ev.preventDefault(); showPanel(); });
    const c = document.getElementById('closePanelBtn');
    if(c) c.addEventListener('click', function(ev){ ev.preventDefault(); hidePanel(); });

    // ===== Delegated click for mobile composer cards =====
    document.addEventListener('click', function(ev){
      try{
        if (ev.target.closest('#panel-left, #mobileSidePanel, #mf-filters, .filters-panel')) return;
        if (window.innerWidth > 600) return;
        if (ev.target.closest('a, button')) return;

        const about = ev.target.closest('.about-label, .about-badge');
        if (!about) return;
        const card = about.closest('.result-card');
        if (!card) return;

        ev.preventDefault();
        ev.stopPropagation();

        populateAndShowFromCard(card);
      }catch(e){}
    }, true);

    // ===== Pointerup fallback for touch =====
    (function(){
      let lastHandled = 0;
      document.addEventListener('pointerup', function(ev){
        try{
          if (Date.now() - lastHandled < 300) return;
          if (window.innerWidth > 600) return;
          if (!ev) return;
          if (ev.pointerType && ev.pointerType !== 'touch') return;
          if (ev.target.closest('a, button')) return;

          const about = ev.target.closest('.about-label, .about-badge');
          if (!about) return;
          const card = about.closest('.result-card');
          if (!card) return;

          lastHandled = Date.now();
          ev.preventDefault();
          ev.stopPropagation();
          populateAndShowFromCard(card);
        }catch(e){}
      }, true);
    })();
  });

  // ===== Expose to other scripts =====
  window.showMobileComposerPanel = showPanel;
  window.hideMobileComposerPanel = hidePanel;
  window.populateMobilePanelFromCard = populateAndShowFromCard;
})();
</script>


        <script>
 (function() {
  const panel = document.getElementById('mobileSidePanel');
  const mobileContent = document.getElementById('mobilePanelContent');

  if (!panel || !mobileContent) {
    console.warn('❌ Mobile panel or content div not found');
    return;
  }

  // Helper to show the mobile panel
  function showMobilePanel() {
    panel.style.display = 'block';
    panel.style.opacity = '1';
    panel.style.visibility = 'visible';
    panel.style.zIndex = '99999';
    if ('inert' in panel) panel.inert = false;
    panel.setAttribute('aria-hidden', 'false');
  }

  // Helper to update mobile content with composer HTML
  function updateMobileContent(html) {
    if (!html || html.includes('Select a result')) return;

    // Wrap it for consistent styling
    mobileContent.innerHTML = `<div class="composer-card">${html}</div>`;

    // Optional visual debug flash
    mobileContent.style.outline = '3px solid magenta';
    setTimeout(() => mobileContent.style.outline = '', 1000);
  }

  // 1️⃣ Pre-populate if desktop already has content
  const desktop = document.getElementById('composer-content');
  if (desktop && desktop.innerHTML && !desktop.innerHTML.includes('Select a result')) {
    showMobilePanel();
    updateMobileContent(desktop.innerHTML);
    console.log('✅ Mobile panel initialized with existing desktop content');
  } else {
    console.log('ℹ️ Mobile panel waiting for composerPopulated events');
  }

  // 2️⃣ Listen for composerPopulated events from desktop panel
  document.addEventListener('composerPopulated', e => {
    const html = e?.detail?.html;
    if (!html) return;

    showMobilePanel();
    updateMobileContent(html);
    console.log('✅ Mobile panel updated from composerPopulated event');
  });

})();
</script>

      <script>
        (function(){
          // Guard against double-injection
          if (window.mobileDebugFilter) return;

          // A lightweight helper that prefers the canonical loadResults() when present,
          // but can fall back to a simple DOM-only filter for static .result-card elements.
          window.mobileDebugFilter = {
            filterResults() {
              try {
                // If the full client runtime is available, prefer it so server-driven
                // rendering and pagination remain authoritative.
                if (typeof window.loadResults === 'function') {
                  // call with no rows to trigger the normal fetch/filter cycle
                  window.loadResults();
                  return;
                }

                // Fallback: simple DOM filter for .result-card elements on the page.
                const qEl = document.querySelector('#qinput');
                const q = (qEl && qEl.value || '').toLowerCase().trim();

                // Read selected country filters if present. Use input[name=filter-country] when available,
                // otherwise fall back to any checked checkbox inside #panel-left.
                const countryChecks = Array.from(document.querySelectorAll('#panel-left input[name="filter-country"]:checked'))
                  .map(i => (i.value || '').toLowerCase());
                const fallbackChecks = countryChecks.length ? countryChecks : Array.from(document.querySelectorAll('#panel-left input[type="checkbox"]:checked')).map(i => (i.value||'').toLowerCase());

                document.querySelectorAll('.result-card').forEach(card => {
                  const text = (card.textContent || '').toLowerCase();
                  let visible = true;
                  if (q && !text.includes(q)) visible = false;
                  if (fallbackChecks.length) {
                    // show card only if any selected checkbox value appears in the card text
                    if (!fallbackChecks.some(v => v && text.includes(v))) visible = false;
                  }
                  card.style.display = visible ? '' : 'none';
                });
              } catch (err) {
                // defensive: don't let a debug helper break the page
                console.warn('mobileDebugFilter.filterResults error', err);
              }
            },

            attachBindings(root){
              try {
                const container = (root && root.querySelector) ? root : document;

                // Attach to qinput (search) if present
                const qEl = container.querySelector('#qinput') || document.querySelector('#qinput');
                if (qEl && !qEl.__mobileDebugBound) {
                  qEl.addEventListener('input', () => window.mobileDebugFilter.filterResults());
                  qEl.__mobileDebugBound = true;
                }

                // Generic binder for checkboxes that syncs counterpart (desktop <-> mobile clone)
                function bindCheckbox(cb){
                  if (!cb || cb.__mobileDebugBound) return;
                  const handler = function onChange(){
                    try{
                      // If this change was induced by the sync mechanism, consume the flag and do nothing
                      if (cb.__mobileDebugSyncing){ cb.__mobileDebugSyncing = false; return; }

                      const name = cb.name;
                      const value = cb.value;
                      const checked = cb.checked;
                      const inDesktop = !!cb.closest('#panel-left');
                      const desktopPanel = document.querySelector('#panel-left');
                      const mobilePanel = document.querySelector('#panel-left-mobile-clone');
                      const targetPanel = inDesktop ? (mobilePanel || desktopPanel) : (desktopPanel || mobilePanel);
                      if (targetPanel){
                        const match = Array.from(targetPanel.querySelectorAll(`input[name="${name}"]`)).find(x => String(x.value) === String(value));
                        if (match && match !== cb){
                          try{
                            // Mark the counterpart so its handler ignores the induced change
                            match.__mobileDebugSyncing = true;
                            if (match.checked !== checked) {
                              match.checked = checked;
                              try{ match.dispatchEvent(new Event('change', { bubbles: true })); }catch(_){ }
                            }
                          }catch(_){ }
                        }
                      }
                    }catch(_){ }
                    // Finally, update results based on the new state
                    try{ window.mobileDebugFilter.filterResults(); }catch(_){ }
                  };
                  cb.addEventListener('change', handler);
                  cb.__mobileDebugBound = true;
                }

                // Attach to all checkboxes inside #panel-left and any clone within the given container
                const checkboxSelector = 'input[type="checkbox"]';
                Array.from(container.querySelectorAll(checkboxSelector)).forEach(cb => bindCheckbox(cb));

                // Also ensure top-level panel-left and clone checkboxes are bound (in case root was a subtree)
                try{ Array.from(document.querySelectorAll('#panel-left input[type="checkbox"], #panel-left-mobile-clone input[type="checkbox"]')).forEach(cb => bindCheckbox(cb)); }catch(_){ }

              } catch (err) {
                console.warn('mobileDebugFilter.attachBindings error', err);
              }
            }
          };

          // Run on DOMContentLoaded to bind visible inputs immediately.
          document.addEventListener('DOMContentLoaded', function(){
            try {
              window.mobileDebugFilter.attachBindings(document);
            } catch (e) {
              console.warn('mobileDebugFilter init failed', e);
            }
          });

          // Observe for dynamically added clones/overlays and attach bindings when they appear.
          try {
            const obs = new MutationObserver(mutations => {
              for (const m of mutations) {
                if (!m.addedNodes) continue;
                for (const n of m.addedNodes) {
                  if (!(n instanceof HTMLElement)) continue;
                  if (n.classList && n.classList.contains('mobile-overlay-clone')) {
                    // attach within the clone
                    window.mobileDebugFilter.attachBindings(n);
                  } else {
                    // occasionally clones are nested; search inside the added subtree
                    const clone = n.querySelector && n.querySelector('.mobile-overlay-clone');
                    if (clone) window.mobileDebugFilter.attachBindings(clone);
                  }
                }
              }
            });
            obs.observe(document.body || document.documentElement, { childList: true, subtree: true });
          } catch (e) {
            // ignore observer failures on very old browsers
          }

        })();
      </script>