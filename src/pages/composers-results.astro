<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Soviet Trumpet Archive results</title>
  <style>
    :root { --accent:#8b0000; --muted:#6b7280; --bg:#f7f9fc; }
    * { box-sizing:border-box; }
    body { padding-bottom:64px; }
    header { background:white; border-bottom:1px solid #e6e9ef; position:sticky; top:0; z-index:30; }
    header .container { width:100%; max-width:none; margin:0; padding:12px 20px; }
    #navEnglish { display:inline-block; padding-left:0; }
    .container { max-width:1100px; margin:0 auto; padding:20px; }
    .nav { display:flex; align-items:center; gap:18px; }
    .logo { font-weight:800; color:var(--accent); font-size:20px; }
    .nav-english { color:var(--accent); font-weight:800; }
    .nav-pipe { color:#000; margin:0 8px; }
    .nav-russian { color:var(--muted); }
    .lang-toggle { position:relative; display:inline-block; margin-right:12px; }
    .lang-btn { background:transparent; border:1px solid #e6e9ef; padding:6px 8px; border-radius:6px; cursor:pointer; font-weight:600; }
    .lang-dropdown { position:absolute; top:100%; right:0; background:white; border:1px solid #e6e9ef; border-radius:6px; padding:6px; box-shadow:0 6px 18px rgba(16,24,40,0.06); display:none; min-width:140px; }
    .lang-dropdown.open { display:block; }
    .lang-option { padding:6px 8px; cursor:pointer; }
    .lang-option:hover { background:#f3f4f6; }
    #fixed-footer { position:fixed; left:0; right:0; bottom:0; background:#8b0000; color:white; z-index:60; box-shadow:0 -6px 18px rgba(11,10,10,0.2); padding:8px 0 0 0; }
    .fixed-footer-inner { width:100%; max-width:none; margin:0; padding:0 20px; display:flex; gap:12px; justify-content:space-between; align-items:center; }
    .footer-left { display:flex; flex-direction:column; transform: translateY(-5px); }
    .footer-left .title { font-weight:700; color:white; font-size:16px; line-height:1.1; padding:12px 0 0 0; margin-left:0; }
    .footer-left .subtitle { color:rgba(255,255,255,0.8); font-size:13px; margin-top:0; margin-left:0; padding-left:0; }
    .fixed-footer-center { flex:1; display:flex; align-items:center; justify-content:center; transform: translateY(-3px); }
    .fixed-footer-center .links { color:white; font-size:13px; text-align:center; }
    .fixed-footer-center .links a { color:inherit; text-decoration:none; margin:0 8px; }
    .fixed-footer-right { display:flex; align-items:center; justify-content:flex-end; min-width:220px; transform: translateY(-3px); }
    .fixed-footer-right .copyright { color:rgba(255,255,255,0.9); font-size:13px; }
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      background: transparent; /* show the overlay behind the page */
      color: #333;
    }

    /* Navbar: match composers page height and style */
    header {
      background: white;
      border-bottom: 1px solid #e6e9ef;
      position: sticky;
      top: 0;
        z-index: 40;
    }
    header .container { width:100%; max-width:none; margin:0; padding:12px 20px; display:flex; align-items:center; justify-content:space-between; }
    .logo { font-weight:800; color:var(--accent); font-size:20px; line-height:1; }
    header h1 { margin:0; font-size:1.5rem; color:var(--accent); }

    .search-bar {
      background: #e9ecef;
      opacity: 0.75; /* make the gray search box 75% opaque */
      padding: 1rem;
      text-align: center;
      display:flex;
      flex-direction:row;
      align-items:center;
      gap:8px;
      justify-content:center;
        position: relative;
        z-index: 42; /* make sure search bar sits above background overlay */
    }
    .search-bar input {
      width: 60%;
      padding: 0.5rem;
      font-size: 1rem;
    }
    .search-bar button {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      margin-left: .5rem;
      background: var(--accent); /* maroon */
      color: white;
      border: none;
      cursor: pointer;
    }

    .container {
      display: grid;
  /* left filters, main results, right composer box (composer box widened to align with search button) */
  grid-template-columns: 250px 1fr 420px;
      gap: 1rem;
      /* full-bleed container so left column (filters) sits flush to viewport left */
      padding: 1rem 10px 1rem 0;
      position: relative;
      z-index: 10; /* put main content above the background overlay */
      max-width: none;
      margin: 0;
      width: 100%;
    }

    .filters {
      background: #fffff7;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 10px 30px rgba(16,24,40,0.12);
      /* previously offset from the viewport edge; removed margin so headings/dividers align with other boxes */
      margin-left: 0;
    }
    .filters h3 {
      /* legacy rule - headings now use .section-header for consistent Results-style headings */
      font-size: 1rem;
      margin-bottom: 0.5rem;
    }
    .filters label {
      display: block;
      margin-bottom: 0.5rem;
    }
    .list-title { color: #000; font-weight:700; margin-bottom:6px; font-size:0.95rem; }

    .results {
      background: #fffff7;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 10px 30px rgba(16,24,40,0.12);
    }

    /* Maroon spinner for composer box quick-loading state */
    .spinner {
      width: 18px;
      height: 18px;
      border: 2px solid rgba(139,0,0,0.15);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 800ms linear infinite;
      display:inline-block;
      vertical-align:middle;
      margin-left:8px;
    }
    @keyframes spin { from { transform: rotate(0deg);} to { transform: rotate(360deg);} }

    /* Right-hand composer box (matches filters box style) */
    .composer-box {
      background: #fffff7;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 10px 30px rgba(16,24,40,0.12);
      margin-right: 0; /* flush to the right column edge */
    }
  /* result hyperlinks (composer names and piece titles) should be black with no underline */
  .composer-link, .piece-link { color: #000 !important; font-weight:700; text-decoration:none !important; }
  .composer-link:hover, .piece-link:hover { text-decoration:none !important; }
  /* ensure visited links keep the same black color */
  .composer-link:visited, .piece-link:visited { color: #000 !important; }
  /* stronger selectors in case global rules override link color/decoration */
  .results .result-item a.composer-link, .results .result-item a.piece-link, .result-item a.composer-link, .result-item a.piece-link { color: #000 !important; text-decoration:none !important; }
  .results .result-item a.composer-link:visited, .results .result-item a.piece-link:visited, .result-item a.composer-link:visited, .result-item a.piece-link:visited { color: #000 !important; }
  .composer-box h3 { font-size:1rem; margin-bottom:0.5rem; }

  /* Shared section header that matches the Results header (color, size, line-height) */
  .section-header { margin:0; padding:0; color:var(--accent); font-size:1.125rem; font-weight:700; line-height:1; }
  /* force identical spacing for headings inside the three primary boxes so dividers align */
  .results > .results-header > .section-header,
  .filters > .section-header,
  .composer-box > div > .section-header { display:block; margin:0; padding:0; font-size:1.125rem; line-height:1; }
  /* nudge the Filters heading slightly lower for perfect alignment */
  .filters > .section-header { transform: translateY(3px); }
  .section-divider { border-bottom:1px solid #e6e9ef; margin-top:8px; margin-bottom:12px; }
  /* nudge only the Filters box divider down slightly to match visual alignment */
  .filters > .section-divider { transform: translateY(3px); }
    .pagination { display:flex; gap:8px; align-items:center; justify-content:center; margin-top:12px; }
    .pagination button { padding:6px 10px; border-radius:6px; border:1px solid #d1d5db; background:white; cursor:pointer; }
    .pagination button.active { background:var(--accent); color:white; border-color:var(--accent); }
    .result-item {
      border-bottom: 1px solid #d1d5db; /* clearer gray divider between entries */
      padding: 1rem 0;
    }
    /* ensure divider isn't overridden by other layout rules */
    .results .result-item { border-bottom: 1px solid #d1d5db !important; }
    .result-item:last-child {
      border-bottom: none;
    }
    .result-item h2 {
      font-size: 1.2rem;
      margin: 0;
      color: #004d7a;
      cursor: pointer;
    }
    .result-item p {
      margin: 0.25rem 0;
    }

    /* Make bold text maroon to match site accent */
    strong, .filters h3 strong { color: var(--accent); font-weight:700; }

    footer {
      background: #004d7a;
      color: white;
      text-align: center;
      padding: 1rem;
      margin-top: 2rem;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>

  <!-- background overlay (copied from front page) -->
  <div id="bg-overlay" aria-hidden="true">
    <img id="bg-img" src="/assets/bg-K13qQAs.png" alt="" />
  </div>

  <!-- Background adjustment control (visible for quick tweaks) -->
  <div id="bg-adjust-control" aria-hidden="false">
    <button id="bg-up" title="Move background up">▲</button>
    <div id="bg-value">18</div>
    <button id="bg-down" title="Move background down">▼</button>
    <button id="bg-reset" title="Reset background">Reset</button>
  </div>

  <style>
  /* make the background overlay cover the viewport and sit behind content but above page background */
  #bg-overlay { position:fixed; inset:0; z-index:-1; overflow:hidden; pointer-events:none; }
  #bg-overlay img { position:absolute; left:0; top:0; transform-origin:0 0; will-change:left,top,width,height; }
    #bg-adjust-control{position:fixed;left:12px;bottom:80px;z-index:80;background:rgba(255,255,255,0.95);border:1px solid #e6e9ef;padding:6px 8px;border-radius:8px;display:flex;gap:6px;align-items:center;box-shadow:0 6px 18px rgba(16,24,40,0.08)}
    #bg-adjust-control button{background:#fff;border:1px solid #d1d5db;padding:6px;border-radius:6px;cursor:pointer}
    #bg-adjust-control #bg-value{min-width:36px;text-align:center;font-weight:600}
    @media (max-width:600px){ #bg-adjust-control{left:8px;bottom:92px} }
  </style>

  <script>
    (function(){
      // Image natural dimensions and the focal point in image coordinates
      const IMG_W = 1920, IMG_H = 1080;
      const FOCUS_X = 955, FOCUS_Y = 325;
      const img = document.getElementById('bg-img');
      const overlay = document.getElementById('bg-overlay');
      if (!img || !overlay) return;

      // tweak this value (px) to nudge the background vertically: positive moves it down
      // read saved value from localStorage so adjustments persist
      const BG_Y_ADJUST_KEY = 'bg_y_adjust';
      let BG_Y_ADJUST = (function(){
        try{ const v = parseInt(localStorage.getItem(BG_Y_ADJUST_KEY)); return Number.isFinite(v) ? v : 18; }catch(e){ return 18; }
      })();
  let _pending = false;
      function applyFocus(){
        if (_pending) return;
        _pending = true;
        requestAnimationFrame(()=>{
          try{
            // make the background flush to all viewport corners
            const vw = Math.max(window.innerWidth || document.documentElement.clientWidth, 0);
            const vh = Math.max(window.innerHeight || document.documentElement.clientHeight, 0);
            img.style.width = vw + 'px';
            img.style.height = vh + 'px';
            img.style.left = '0px';
            // allow a small saved vertical nudge while keeping the image covering the viewport
            img.style.top = (typeof BG_Y_ADJUST === 'number' ? BG_Y_ADJUST : 0) + 'px';
          }catch(e){
            console.error('applyFocus error', e);
          }finally{
            _pending = false;
          }
        });
      }

      // re-run on resize and when image loads; also run on window load and when fonts/images settle
      img.addEventListener('load', applyFocus);
      window.addEventListener('resize', applyFocus);
      // Run once on window load to ensure layout is stable
      window.addEventListener('load', ()=>{ setTimeout(applyFocus, 80); });
      // If the page uses the Font Loading API, re-run when fonts are ready
      if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(()=> setTimeout(applyFocus, 60)).catch(()=>{});
      }
      // run shortly after load in case other layout shifts occur
      setTimeout(applyFocus, 250);
      // initial apply
      if (img.complete) applyFocus();
      else setTimeout(()=>{ if(img.complete) applyFocus(); }, 200);
    })();
  </script>

  <script>
    // Wire up the BG adjust controls to persist and re-run applyFocus
    (function(){
      const up = document.getElementById('bg-up');
      const down = document.getElementById('bg-down');
      const val = document.getElementById('bg-value');
      const reset = document.getElementById('bg-reset');
      if (!up || !down || !val || !reset) return;
      function read(){ return (function(){ try{ const v = parseInt(localStorage.getItem('bg_y_adjust')); return Number.isFinite(v) ? v : 18; }catch(e){ return 18; } })(); }
      function write(v){ try{ localStorage.setItem('bg_y_adjust', String(v)); }catch(e){} }
      function updateDisplay(){ const n = read(); val.textContent = n; window.dispatchEvent(new Event('resize')); setTimeout(()=>{ try{ document.querySelector('#bg-img') && document.querySelector('#bg-img').dispatchEvent(new Event('load')); }catch(e){} }, 60); }
      up.addEventListener('click', ()=>{ const n = read() - 1; write(n); updateDisplay(); });
      down.addEventListener('click', ()=>{ const n = read() + 1; write(n); updateDisplay(); });
      reset.addEventListener('click', ()=>{ write(18); updateDisplay(); });
      // init
      val.textContent = read();
    })();
  </script>

  <header>
    <div class="container nav" style="display:flex;justify-content:space-between;align-items:center">
      <a href="/composers" class="logo" style="text-decoration:none;color:inherit;display:flex;align-items:center;gap:8px;">
        <span class="nav-english" id="navEnglish">Archive of Soviet Trumpet Music</span>
        <span class="nav-pipe">|</span>
        <span class="nav-russian" id="navRussian">Архив советской трубной музыки</span>
      </a>
      <div class="lang-toggle" id="langToggle">
        <button class="lang-btn" id="langBtn">EN ▾</button>
        <div class="lang-dropdown" id="langDropdown">
          <div class="lang-option" data-locale="en">English</div>
          <div class="lang-option" data-locale="de">Deutsch</div>
        </div>
      </div>
    </div>
  </header>

<div class="search-bar">
  <input id="qinput" type="text" placeholder="Search ProQuest...">
  <button id="qbtn">Search</button>
</div>

<!-- pagination controls will be injected inside the results box so the right edge can align with the results column -->

<div class="container">
  <aside class="filters">
    <h3 class="section-header"><strong>Filters</strong></h3>
    <div class="section-divider"></div>
    <!-- Clear-all moved to the pagination area to match original layout -->
  <h4 class="section-header" style="font-weight:600;margin-top:6px;margin-bottom:6px;"><strong>Country</strong></h4>
  <div class="section-divider"></div>
  <div id="filter-country" style="margin-bottom:12px;">&nbsp;</div>

  <h4 class="section-header" style="font-weight:600;margin-top:6px;margin-bottom:6px;"><strong>Decade</strong></h4>
  <div class="section-divider"></div>
    <div id="filter-decade" style="margin-bottom:12px;">&nbsp;</div>

    <h4 class="section-header" style="font-weight:600;margin-top:6px;margin-bottom:6px;"><strong>Type of piece</strong></h4>
    <div class="section-divider"></div>
    <div id="filter-type" style="margin-bottom:12px;">&nbsp;</div>
  </aside>

  <main class="results" id="results">
    <div class="results-header" style="display:flex;align-items:center;justify-content:space-between;gap:12px;">
      <h3 class="section-header">Results</h3>
      <div id="results-pagination-top" style="display:flex;align-items:center;justify-content:flex-end;"></div>
    </div>
    <div class="section-divider"></div>
    <div id="results-list">
      <div class="result-item"><em>Loading results…</em></div>
    </div>
  </main>

  <aside class="composer-box" id="composer-box">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;">
      <h3 class="section-header">Composer</h3>
      <div style="margin-left:auto;">
        <button id="clear-composer" style="display:none;padding:6px 10px;border-radius:6px;border:1px solid #d1d5db;background:#fff;">Clear composer</button>
      </div>
    </div>
    <div class="section-divider"></div>
    <div id="composer-content" style="margin-top:8px;">Select a result to view composer details.</div>
  </aside>
</div>

  <!-- Fixed footer bar locked to viewport (shared with main site) -->
  <div id="fixed-footer" aria-hidden="false" role="contentinfo">
    <div class="fixed-footer-inner">
      <div class="footer-left">
        <div class="title">Archive of Soviet Trumpet Music</div>
        <div class="subtitle">Архив советской трубной музыки</div>
      </div>
      <div class="fixed-footer-center">
        <div class="links">
          <a href="/about">About</a>
          <a href="#">Contact</a>
          <a href="#">Help</a>
        </div>
      </div>
      <div class="fixed-footer-right">
        <div class="copyright">© 2025 Archive of Soviet Trumpet Music</div>
      </div>
    </div>
  </div>

<script>
  // populate the search input from query param and match front-page placeholder
  const params = new URLSearchParams(window.location.search);
  const q = params.get('q') || '';
  const qinput = document.getElementById('qinput');
  qinput.placeholder = 'Search composers, countries, or pieces...';
  qinput.value = decodeURIComponent(q);

  // language toggle: simple behavior to set locale and reload
  const langBtn = document.getElementById('langBtn');
  const langDropdown = document.getElementById('langDropdown');
  if (langBtn && langDropdown){
    langBtn.addEventListener('click', ()=>{ langDropdown.classList.toggle('open'); langBtn.setAttribute('aria-expanded', String(langDropdown.classList.contains('open'))); });
    langDropdown.addEventListener('click', (e)=>{ const opt = e.target.closest('.lang-option'); if (!opt) return; const locale = opt.dataset.locale; try{ localStorage.setItem('locale', locale); }catch(e){} window.location.reload(); });
    document.addEventListener('click', (e)=>{ if (!langBtn.contains(e.target) && !langDropdown.contains(e.target)) langDropdown.classList.remove('open'); });
  }

  function normalize(s){ if(!s) return ''; try{ return s.toString().normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase(); }catch(e){ return s.toString().normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase(); } }

  // Top-level clear function so the button in filters can reuse it
  function clearAllFilters(){
    try{
      if (qinput) qinput.value = '';
      selectedComposer = '';
      selectedPieceIndex = null;
      selectedPieceFilter = null; // when set, filter results to this piece title
      lastAppliedFilter = null;
      const clearComposerBtn = document.getElementById('clear-composer'); if (clearComposerBtn) clearComposerBtn.style.display = 'none';
      const composerContent = document.getElementById('composer-content'); if (composerContent) composerContent.innerHTML = 'Select a result to view composer details.';
      document.querySelectorAll('#filter-country input[type=checkbox], #filter-decade input[type=checkbox], #filter-type input[type=checkbox]').forEach(cb=> cb.checked = false);
      currentPage = 1;
      loadResults();
    }catch(e){ console.error('clearAllFilters failed', e); }
  }

  function escapeHtml(str){ if (str == null) return ''; return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

  // Client-side GViz fetch fallback for public spreadsheets.
  async function gvizFetch(sheetName, range = 'A1:Z1000'){
    try{
      const id = '1UiK8QDq98C-9wCpQjdQAVpSdH8mZkpxYgMMEHM3uaGk'; // same spreadsheet id as server
      const url = `https://docs.google.com/spreadsheets/d/${id}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(sheetName)}&range=${encodeURIComponent(range)}`;
      const txt = await (await fetch(url)).text();
      const m = txt.match(/google\.visualization\.Query\.setResponse\((.*)\);?/s);
      if (!m || !m[1]) return null;
      const json = JSON.parse(m[1]);
      if (!json || !json.table) return null;
      const cols = (json.table.cols || []).map(c => (c && (c.label || c.id)) ? String(c.label || c.id) : '');
      const rows = (json.table.rows || []).map(r => (r.c || []).map(cell => (cell && cell.v !== undefined && cell.v !== null) ? cell.v : ''));
      return { cols, rows };
    }catch(_){ return null; }
  }

  // pagination state
  const PAGE_SIZE = 25;
  let currentPage = 1;
  let lastFiltered = [];
  let selectedComposer = '';
  let selectedPieceIndex = null;
  // remember the last filter the user changed so "Return to search" can drop it
  let lastAppliedFilter = null; // { kind: 'country'|'decade'|'type', value: '<data-val string>' }
  // live update state
  let lastRowsJson = null;
  const POLL_INTERVAL = 30000; // 30s
  let liveTimer = null;

  // populate country checkboxes from translations (canonical EN list + localized labels)
  async function populateCountryCheckboxes(){
    const container = document.getElementById('filter-country');
    if (!container) return;
    // fallback canonical list
    const fallbackCountries = ['Russia','Ukraine','Belarus','Armenia','Georgia','Latvia','Estonia','Lithuania','Kazakhstan','Uzbekistan','Other'];
    try{
      const res = await fetch('/i18n/translations.json');
      const json = await res.json();
      const en = json && json.en ? json.en : null;
      const canonical = en && en.countries ? en.countries : fallbackCountries;
      // determine locale for localized labels
      const locale = (function(){ try{ return localStorage.getItem('locale') || 'en'; }catch(e){ return 'en'; } })();
      const localized = (json && json[locale] && json[locale].countries) ? json[locale].countries : canonical;
      // build title + checkbox list; controls will be placed at the bottom
  container.innerHTML = '';
      // build checkbox list
      for (let i=0;i<canonical.length;i++){
        const val = canonical[i];
        const lab = (localized && localized[i]) ? localized[i] : val;
        const id = 'country_cb_' + i;
        const wrapper = document.createElement('div');
        wrapper.innerHTML = `<label style="display:block;margin-bottom:6px;"><input type="checkbox" data-val="${encodeURIComponent(val)}" id="${id}" /> ${lab}</label>`;
        container.appendChild(wrapper);
      }
      // build controls (Select All / Clear) placed at bottom
      const controls = document.createElement('div');
      controls.style.marginTop = '8px';
      controls.innerHTML = `<button id="country-select-all" style="margin-right:6px;padding:4px 8px;border-radius:6px;border:1px solid #d1d5db;background:#fff;">Select All</button><button id="country-clear" style="padding:4px 8px;border-radius:6px;border:1px solid #d1d5db;background:#fff;">Clear</button>`;
      container.appendChild(controls);
    // attach change handler to all checkboxes
  container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.addEventListener('change', (e)=>{ try{ const val = decodeURIComponent(cb.dataset.val || cb.getAttribute('data-val')||''); lastAppliedFilter = { kind: 'country', value: val }; }catch(_){} selectedComposer = ''; currentPage = 1; loadResults(); }));
      // wire select all / clear
      const selAll = document.getElementById('country-select-all');
      const clr = document.getElementById('country-clear');
  if (selAll) selAll.addEventListener('click', ()=>{ lastAppliedFilter = null; container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.checked = true); currentPage = 1; loadResults(); });
  if (clr) clr.addEventListener('click', ()=>{ lastAppliedFilter = null; container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.checked = false); currentPage = 1; loadResults(); });
    }catch(e){
      // fallback: render simple list + controls
  container.innerHTML = fallbackCountries.map((c,i)=>`<label style="display:block;margin-bottom:6px;"><input type="checkbox" data-val="${encodeURIComponent(c)}" id="country_cb_f${i}" /> ${c}</label>`).join('');
  const controlsWrap = document.createElement('div');
  controlsWrap.style.marginTop = '8px';
  controlsWrap.innerHTML = `<button id="country-select-all" style="margin-right:6px;padding:4px 8px;border-radius:6px;border:1px solid #d1d5db;background:#fff;">Select All</button><button id="country-clear" style="padding:4px 8px;border-radius:6px;border:1px solid #d1d5db;background:#fff;">Clear</button>`;
  container.appendChild(controlsWrap);
    container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.addEventListener('change', (e)=>{ try{ const val = decodeURIComponent(cb.dataset.val || cb.getAttribute('data-val')||''); lastAppliedFilter = { kind: 'decade', value: val }; }catch(_){} selectedComposer = ''; currentPage = 1; loadResults(); }));
      const selAll = document.getElementById('country-select-all');
      const clr = document.getElementById('country-clear');
  if (selAll) selAll.addEventListener('click', ()=>{ lastAppliedFilter = null; container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.checked = true); currentPage = 1; loadResults(); });
  if (clr) clr.addEventListener('click', ()=>{ lastAppliedFilter = null; container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.checked = false); currentPage = 1; loadResults(); });
    }
  }

  // populate decades checkboxes from translations
  async function populateDecadeCheckboxes(){
    const container = document.getElementById('filter-decade');
    if (!container) return;
    const fallbackDecades = ['1920s','1930s','1940s','1950s','1960s','1970s','1980s'];
    try{
      const res = await fetch('/i18n/translations.json');
      const json = await res.json();
      const en = json && json.en ? json.en : null;
      const canonical = en && en.decades ? en.decades : fallbackDecades;
      const locale = (function(){ try{ return localStorage.getItem('locale') || 'en'; }catch(e){ return 'en'; } })();
      const localized = (json && json[locale] && json[locale].decades) ? json[locale].decades : canonical;
      // title + checkbox list; put controls at the bottom
      container.innerHTML = '';
      const title = document.createElement('div'); title.className = 'list-title'; title.textContent = 'Decade'; container.appendChild(title);
      for (let i=0;i<canonical.length;i++){
        const val = canonical[i];
        const lab = (localized && localized[i]) ? localized[i] : val;
        const id = 'decade_cb_' + i;
        const wrapper = document.createElement('div');
        wrapper.innerHTML = `<label style="display:block;margin-bottom:6px;"><input type="checkbox" data-val="${encodeURIComponent(val)}" id="${id}" /> ${lab}</label>`;
        container.appendChild(wrapper);
      }
      const controls = document.createElement('div'); controls.style.marginTop = '8px'; controls.innerHTML = `<button id="decade-select-all" style="margin-right:6px;padding:4px 8px;border-radius:6px;border:1px solid #d1d5db;background:#fff;">Select All</button><button id="decade-clear" style="padding:4px 8px;border-radius:6px;border:1px solid #d1d5db;background:#fff;">Clear</button>`; container.appendChild(controls);
  container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.addEventListener('change', ()=>{ selectedComposer = ''; currentPage = 1; loadResults(); }));
      const selAll = document.getElementById('decade-select-all');
      const clr = document.getElementById('decade-clear');
      if (selAll) selAll.addEventListener('click', ()=>{ container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.checked = true); currentPage = 1; loadResults(); });
      if (clr) clr.addEventListener('click', ()=>{ container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.checked = false); currentPage = 1; loadResults(); });
    }catch(e){
      container.innerHTML = '';
      const title = document.createElement('div'); title.className = 'list-title'; title.textContent = 'Decade'; container.appendChild(title);
      container.innerHTML += fallbackDecades.map((d,i)=>`<label style="display:block;margin-bottom:6px;"><input type="checkbox" data-val="${encodeURIComponent(d)}" id="decade_cb_f${i}" /> ${d}</label>`).join('');
      const controlsWrap = document.createElement('div'); controlsWrap.style.marginTop = '8px'; controlsWrap.innerHTML = `<button id="decade-select-all" style="margin-right:6px;padding:4px 8px;border-radius:6px;border:1px solid #d1d5db;background:#fff;">Select All</button><button id="decade-clear" style="padding:4px 8px;border-radius:6px;border:1px solid #d1d5db;background:#fff;">Clear</button>`; container.appendChild(controlsWrap);
      container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.addEventListener('change', ()=>{ currentPage = 1; loadResults(); }));
    }
  }

  // populate type-of-piece checkboxes by deriving unique types from the sheets if translations do not provide them
  async function populateTypeCheckboxes(){
    const container = document.getElementById('filter-type');
    if (!container) return;
    container.innerHTML = '';
    try{
      // try translations first
      const resT = await fetch('/i18n/translations.json');
      const jsonT = await resT.json();
      const en = jsonT && jsonT.en ? jsonT.en : null;
      const canonicalTypes = en && en.types ? en.types : null;
      if (canonicalTypes && canonicalTypes.length){
        const localized = (jsonT && jsonT[(localStorage.getItem('locale')||'en')] && jsonT[(localStorage.getItem('locale')||'en')].types) ? jsonT[(localStorage.getItem('locale')||'en')].types : canonicalTypes;
        // title + checkboxes, controls at bottom
        container.innerHTML = '';
        const title = document.createElement('div'); title.className = 'list-title'; title.textContent = 'Type of piece'; container.appendChild(title);
        canonicalTypes.forEach((val,i)=>{
          const lab = localized && localized[i] ? localized[i] : val;
          const id = 'type_cb_' + i;
          const wrapper = document.createElement('div');
          wrapper.innerHTML = `<label style="display:block;margin-bottom:6px;"><input type="checkbox" data-val="${encodeURIComponent(val)}" id="${id}" /> ${lab}</label>`;
          container.appendChild(wrapper);
        });
        const controls = document.createElement('div'); controls.style.marginTop = '8px'; controls.innerHTML = `<button id="type-select-all" style="margin-right:6px;padding:4px 8px;border-radius:6px;border:1px solid #d1d5db;background:#fff;">Select All</button><button id="type-clear" style="padding:4px 8px;border-radius:6px;border:1px solid #d1d5db;background:#fff;">Clear</button>`; container.appendChild(controls);
  container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.addEventListener('change', (e)=>{ try{ const val = decodeURIComponent(cb.dataset.val || cb.getAttribute('data-val')||''); lastAppliedFilter = { kind: 'type', value: val }; }catch(_){} currentPage = 1; loadResults(); }));
        const selAll = document.getElementById('type-select-all');
        const clr = document.getElementById('type-clear');
  if (selAll) selAll.addEventListener('click', ()=>{ lastAppliedFilter = null; container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.checked = true); currentPage = 1; loadResults(); });
  if (clr) clr.addEventListener('click', ()=>{ lastAppliedFilter = null; container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.checked = false); currentPage = 1; loadResults(); });
        return;
      }
      // otherwise derive types from the sheets
  const res = await fetch('/api/sheets', { headers: { 'Accept': 'application/json' } });
  const raw = await res.json().catch(()=>null);
  const rows = Array.isArray(raw) ? raw : (raw && Array.isArray(raw.rows) ? raw.rows : raw);
      const set = new Set();
      rows.forEach(r => {
        // Prefer explicit type fields, but also check for single-letter column P or variants
        let t = r.Type || r.type || r['Type of piece'] || r['Type'] || '';
        if (!t) {
          // common single-letter header for the sheet-export
          if (r.P !== undefined && r.P !== null && String(r.P).trim() !== '') t = r.P;
          else if (r['P'] !== undefined && r['P'] !== null && String(r['P']).trim() !== '') t = r['P'];
          else if (r.colP !== undefined && r.colP !== null && String(r.colP).trim() !== '') t = r.colP;
        }
        // fallbacks for labelled columns that may contain the type
        if (!t) {
          t = r['Label'] || r['label'] || r['Piece Type'] || r['Type of Piece'] || '';
        }
        if (t) set.add(String(t).trim());
      });
      const list = Array.from(set).sort();
      container.innerHTML = '';
      const titleDyn = document.createElement('div'); titleDyn.className = 'list-title'; titleDyn.textContent = 'Type of piece'; container.appendChild(titleDyn);
      const controls = document.createElement('div'); controls.style.marginTop = '8px'; controls.innerHTML = `<button id="type-select-all" style="margin-right:6px;padding:4px 8px;border-radius:6px;border:1px solid #d1d5db;background:#fff;">Select All</button><button id="type-clear" style="padding:4px 8px;border-radius:6px;border:1px solid #d1d5db;background:#fff;">Clear</button>`; container.appendChild(controls);
      list.forEach((val,i)=>{
        const id = 'type_cb_dyn_' + i;
        const wrapper = document.createElement('div');
        wrapper.innerHTML = `<label style="display:block;margin-bottom:6px;"><input type="checkbox" data-val="${encodeURIComponent(val)}" id="${id}" /> ${val}</label>`;
        container.appendChild(wrapper);
      });
      container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.addEventListener('change', ()=>{ currentPage = 1; loadResults(); }));
      const selAll = document.getElementById('type-select-all');
      const clr = document.getElementById('type-clear');
      if (selAll) selAll.addEventListener('click', ()=>{ container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.checked = true); currentPage = 1; loadResults(); });
      if (clr) clr.addEventListener('click', ()=>{ container.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.checked = false); currentPage = 1; loadResults(); });
    }catch(e){
      // best-effort fallback
      container.innerHTML = '';
    }
  }

  function renderPage(page){
    const container = document.getElementById('results-list');
    container.innerHTML = '';
    const start = (page - 1) * PAGE_SIZE;
    const pageItems = lastFiltered.slice(start, start + PAGE_SIZE);
    if (!pageItems.length) { container.innerHTML = '<div class="result-item">No results</div>'; return; }
    pageItems.forEach(r =>{
      const div = document.createElement('div');
      div.className = 'result-item';
      const title = (r.Title || r.Compositions || 'Untitled');
      const author = r['Composer'] || r.Composer || 'Unknown';
      const published = r.Year || r.Published || r.Decade || '';
      // remove snippet/source (column J) from display per request
      const snippet = '';
  // title and composer name are clickable
  const composerEsc = escapeHtml(author);
  const composerData = encodeURIComponent(String(author || ''));
  const globalIndex = lastFiltered.indexOf(r);
  div.innerHTML = `<h2><a href="#" class="piece-link" data-idx="${globalIndex}">${escapeHtml(title)}</a></h2><p><strong>Composer:</strong> <a href="#" class="composer-link" data-name="${composerData}">${composerEsc}</a></p><p><strong>Published:</strong> ${escapeHtml(published)}</p>`;
      container.appendChild(div);
      // attach click handler for composer link
      const link = div.querySelector('.composer-link');
      if (link){
        link.addEventListener('click', (e)=>{
          e.preventDefault();
          const name = decodeURIComponent(link.dataset.name || '');
          // populate composer box and set filter
          selectedComposer = name || '';
          populateComposerBox(name, r);
          currentPage = 1;
          loadResults();
        });
      }
      // attach click handler for piece title
      const tlink = div.querySelector('.piece-link');
      if (tlink){
        tlink.addEventListener('click', (e)=>{
          e.preventDefault();
          const idx = Number(tlink.dataset.idx);
          if (!Number.isFinite(idx) || idx < 0 || idx >= lastFiltered.length) return;
          const rowObj = lastFiltered[idx];
          const comp = rowObj['Composer'] || rowObj.Composer || '';
          selectedComposer = String(comp || '');
          populateComposerBox(selectedComposer, rowObj);
          // set piece filter and reload results so page shows only that piece
          selectedPieceFilter = String(rowObj.Title || rowObj.Compositions || rowObj['Title'] || rowObj['Compositions'] || '');
          currentPage = 1;
          loadResults();
        });
      }
      // If this row is the selected expanded piece, inject detailed columns J..R (indices 9..17)
      
    });
    renderPagination(Math.ceil(lastFiltered.length / PAGE_SIZE), page);
  }

  function renderPagination(pageCount, active){
    // remove existing pagination if any
    let pag = document.getElementById('pagination');
    if (pag) pag.remove();
  // create pagination container inside the results header top area
  const pagRoot = document.getElementById('results-pagination-top');
  const resultsEl = document.getElementById('results');
  if (!resultsEl || !pagRoot) return;
    pag = document.createElement('div');
    pag.id = 'pagination';
    pag.className = 'pagination';
    // if there is exactly one page, show a '1 of 1' placeholder aligned to the right
    // helper to clear search and all filters (defined at top-level so it can be reused)

    if (pageCount === 1) {
      pagRoot.innerHTML = '';
      // create container with placeholder and clear button
      const phWrap = document.createElement('div');
      phWrap.style.display = 'flex';
      phWrap.style.alignItems = 'center';
      phWrap.style.gap = '8px';
      phWrap.style.justifyContent = 'flex-end';
      const placeholder = document.createElement('div');
      placeholder.style.color = '#6b7280';
      placeholder.style.paddingRight = '6px';
      placeholder.textContent = '1 of 1';
  phWrap.appendChild(placeholder);
  // Clear all filters button for the single-page placeholder
  const clearBtn = document.createElement('button');
  clearBtn.textContent = 'Clear all filters';
  clearBtn.style.padding = '6px 10px';
  clearBtn.style.borderRadius = '6px';
  clearBtn.style.border = '1px solid #d1d5db';
  clearBtn.style.background = '#fff';
  clearBtn.addEventListener('click', ()=>{ try{ clearAllFilters(); }catch(e){} });
  phWrap.appendChild(clearBtn);
      // Live toggle
      const liveToggle = document.createElement('button');
      liveToggle.textContent = 'Live: Off';
      liveToggle.style.marginLeft = '8px';
      liveToggle.style.padding = '6px 10px';
      liveToggle.style.borderRadius = '6px';
      liveToggle.addEventListener('click', ()=>{ if (liveTimer) { stopLiveUpdates(); liveToggle.textContent='Live: Off'; } else { startLiveUpdates(); liveToggle.textContent='Live: On'; } });
      phWrap.appendChild(liveToggle);
      pagRoot.appendChild(phWrap);
      return;
    }

  pag = document.createElement('div');
  pag.id = 'pagination';
  pag.className = 'pagination';
    // prev
    const prev = document.createElement('button'); prev.textContent = 'Prev'; prev.disabled = active === 1; prev.addEventListener('click', ()=>{ if (currentPage>1){ currentPage--; renderPage(currentPage); window.scrollTo({top:0,behavior:'smooth'}); }});
    pag.appendChild(prev);
    // page numbers (limit shown if many)
    const maxButtons = 7;
    const half = Math.floor(maxButtons/2);
    let start = Math.max(1, active - half);
    let end = Math.min(pageCount, start + maxButtons -1);
    if (end - start < maxButtons -1) start = Math.max(1, end - maxButtons +1);
    for (let i=start;i<=end;i++){
      const b = document.createElement('button'); b.textContent = String(i); if (i===active) b.classList.add('active'); b.addEventListener('click', ()=>{ currentPage = i; renderPage(currentPage); window.scrollTo({top:0,behavior:'smooth'}); }); pag.appendChild(b);
    }
    // next
    const next = document.createElement('button'); next.textContent = 'Next'; next.disabled = active >= pageCount; next.addEventListener('click', ()=>{ if (currentPage<pageCount){ currentPage++; renderPage(currentPage); window.scrollTo({top:0,behavior:'smooth'}); }});
    pag.appendChild(next);
    // place pagination inside the results element and align to the right edge of the results box
    // clear any existing pagination top content and insert the new pagination & Clear button
    pagRoot.innerHTML = '';
    const topWrap = document.createElement('div');
    topWrap.style.display = 'flex';
    topWrap.style.alignItems = 'center';
    topWrap.style.gap = '8px';
    topWrap.style.justifyContent = 'flex-end';
  // (Clear button moved to the Filters box at left)
  // Clear all filters button placed next to pagination controls
  const clearBtnTop = document.createElement('button');
  clearBtnTop.textContent = 'Clear all filters';
  clearBtnTop.style.padding = '6px 10px';
  clearBtnTop.style.borderRadius = '6px';
  clearBtnTop.style.border = '1px solid #d1d5db';
  clearBtnTop.style.background = '#fff';
  clearBtnTop.addEventListener('click', ()=>{ try{ clearAllFilters(); }catch(e){} });
  topWrap.appendChild(clearBtnTop);
    // Live toggle button
    const liveToggle2 = document.createElement('button');
    liveToggle2.textContent = liveTimer ? 'Live: On' : 'Live: Off';
    liveToggle2.style.marginRight = '8px';
    liveToggle2.style.padding = '6px 10px';
    liveToggle2.style.borderRadius = '6px';
    liveToggle2.addEventListener('click', ()=>{ if (liveTimer) { stopLiveUpdates(); liveToggle2.textContent='Live: Off'; } else { startLiveUpdates(); liveToggle2.textContent='Live: On'; } });
    topWrap.appendChild(liveToggle2);
    topWrap.appendChild(pag);
    pagRoot.appendChild(topWrap);
  }

  async function pollOnce(){
    try{
  const res = await fetch('/api/sheets', { headers: { 'Accept': 'application/json' } });
  const raw = await res.json().catch(()=>null);
  const rows = Array.isArray(raw) ? raw : (raw && Array.isArray(raw.rows) ? raw.rows : raw);
      const rowsJson = JSON.stringify(rows);
      if (lastRowsJson !== rowsJson){
        lastRowsJson = rowsJson;
        // refresh results without resetting page
        loadResults(rows, { resetPage: false });
      }
    }catch(e){ console.error('poll failed', e); }
  }

  function startLiveUpdates(){
    if (liveTimer) return;
    liveTimer = setInterval(pollOnce, POLL_INTERVAL);
    // run once immediately
    pollOnce();
  }

  function stopLiveUpdates(){ if (!liveTimer) return; clearInterval(liveTimer); liveTimer = null; }

  // loadResults optionally accepts rows (pre-fetched) and an options object { resetPage: true }
  async function loadResults(rowsParam, options = { resetPage: true }){
    try{
  let rows = rowsParam;
  if (!rows){
    const res = await fetch('/api/sheets', { headers: { 'Accept': 'application/json' } });
    const raw = await res.json().catch(()=>null);
    rows = Array.isArray(raw) ? raw : (raw && Array.isArray(raw.rows) ? raw.rows : raw);
  }
      // Defensive: ensure we have an array of rows. If the API returned an error object, try GViz fallback
      if (!Array.isArray(rows)){
        try{
          const g = await gvizFetch('MusicList');
          if (g && g.rows && g.rows.length){
            // build objects from headers
            const headers = g.cols.map((h,i) => h && String(h).trim() ? String(h).trim() : `col_${i}`);
            rows = g.rows.map(r => { const o={}; for(let i=0;i<headers.length;i++){ o[headers[i]] = r[i] !== undefined && r[i] !== null ? r[i] : ''; } return o; });
          } else {
            const errText = typeof rows === 'object' ? JSON.stringify(rows) : String(rows);
            document.getElementById('results').innerText = 'Load failed: unexpected /api/sheets response: ' + errText;
            return;
          }
        }catch(e){ const errText = typeof rows === 'object' ? JSON.stringify(rows) : String(rows); document.getElementById('results').innerText = 'Load failed: unexpected /api/sheets response: ' + errText; return; }
      }
      const qv = normalize(qinput.value || '');
  // read selected countries
  const checked = Array.from(document.querySelectorAll('#filter-country input[type=checkbox]:checked')).map(cb => decodeURIComponent(cb.dataset.val || cb.getAttribute('data-val') || ''));
  // read selected decades
  const checkedDecades = Array.from(document.querySelectorAll('#filter-decade input[type=checkbox]:checked')).map(cb => decodeURIComponent(cb.dataset.val || cb.getAttribute('data-val') || ''));
  // read selected types
  const checkedTypes = Array.from(document.querySelectorAll('#filter-type input[type=checkbox]:checked')).map(cb => decodeURIComponent(cb.dataset.val || cb.getAttribute('data-val') || ''));
  lastFiltered = rows.filter(r => {
        if (qv && !normalize(Object.values(r||{}).join(' ')).includes(qv)) return false;
        // if a piece filter is set (user clicked a title), only include exact matching titles
        if (selectedPieceFilter && selectedPieceFilter.length){
          const titleVal = String(r.Title || r.Compositions || r['Title'] || r['Compositions'] || '').trim();
          if (!titleVal || normalize(titleVal) !== normalize(selectedPieceFilter)) return false;
        }
        if (selectedComposer){
          const comp = (r['Composer'] || r.Composer || '').toString();
          if (!normalize(comp).includes(normalize(selectedComposer))) return false;
        }
        if (checked.length){
          const countryVal = normalize(r.Country || r.Nationality || '');
          // match if any selected country appears in the country field
          const matches = checked.some(sel => normalize(sel) && countryVal.includes(normalize(sel)));
          if (!matches) return false;
        }
        if (checkedDecades.length){
          const decadeVal = normalize(r.Decade || r.Year || '');
          const matches = checkedDecades.some(sel => normalize(sel) && decadeVal.includes(normalize(sel)));
          if (!matches) return false;
        }
        if (checkedTypes.length){
          const typeVal = normalize(r.Type || r.type || r['Type of piece'] || r['Type'] || '');
          const matches = checkedTypes.some(sel => normalize(sel) && typeVal.includes(normalize(sel)));
          if (!matches) return false;
        }
        return true;
      });
      if (options && options.resetPage) currentPage = 1;
      renderPage(currentPage);
      // If caller requested a randomized open (via URL), open composer box for the first matching result
      try{
        const params = new URLSearchParams(window.location.search || '');
        if (params.get('random') === '1' && lastFiltered && lastFiltered.length){
          // pick the first visible result on the current page
          const start = (currentPage - 1) * PAGE_SIZE;
          const first = lastFiltered[start];
          if (first){
            const composerName = first['Composer'] || first.Composer || first['composer'] || Object.values(first)[0] || '';
            selectedComposer = String(composerName || '');
            populateComposerBox(selectedComposer, first);
          }
        }
      }catch(e){ /* ignore */ }
    }catch(e){ document.getElementById('results').innerText = 'Load failed: ' + String(e); }
  }

 async function populateComposerBox(name, row){
  const content = document.getElementById('composer-content');
  const clearBtn = document.getElementById('clear-composer');
  if (!content) return;
  if (!name){
    content.innerHTML = 'Select a result to view composer details.';
    if (clearBtn) clearBtn.style.display = 'none';
    return;
  }

  // small helpers (prefer global normalize if present)
  const normalizeKey = k => String(k || '').toLowerCase().replace(/[^\p{L}\p{N}]+/gu, '').trim();
  const normVal = v => (typeof normalize === 'function') ? normalize(String(v || '')) : String(v || '').toLowerCase().replace(/[^\p{L}\p{N}]+/gu, '').trim();

  // heuristics to decide whether a sheet looks like the CompDet sheet
  const looksLikeCompDet = (sampleObj) => {
    if (!sampleObj || typeof sampleObj !== 'object') return false;
    const keys = Object.keys(sampleObj).map(k => normalizeKey(k));
    const hasComposer = keys.some(k => k.includes('composer') || k.includes('композитор'));
    const hasLife = keys.some(k => k.includes('lifespan') || k.includes('life') || k.includes('born') || k.includes('died') || k.includes('years'));
    const hasCountry = keys.some(k => k.includes('country') || k.includes('republic') || k.includes('nationality') || k.includes('soviet'));
    // indicators of MusicList/main music table (avoid these)
    const looksLikeMusicList = keys.includes('title') || keys.includes('compositions') || keys.includes('snippet') || keys.includes('published');
    // Require composer AND (life OR country) and explicitly exclude music-list-looking sheets
    return hasComposer && (hasLife || hasCountry) && !looksLikeMusicList;
  };

  const candidates = ['CompDet','Sheet2','ComposersAggregated','Composers','Aggregated'];

  let rows = [];
  let sourceSheet = null;

  // QUICK PATH: prefer aggregating from the 'MusicList' sheet (client wants immediate behavior)
  try {
    const mres = await fetch('/api/sheets?sheet=MusicList', { headers: { 'Accept': 'application/json' } });
    const mj = await mres.json().catch(()=>null);
    const mjRows = (mj && Array.isArray(mj)) ? mj : (mj && mj.rows && Array.isArray(mj.rows) ? mj.rows : null);
    if (mjRows && mjRows.length) {
      rows = mjRows;
      sourceSheet = 'MusicList';
      console.debug('COMPOSER_DEBUG using MusicList aggregation (client-side)');
    }
  } catch (e) { /* ignore */ }

  // 1) Try server API for each candidate sheet, but validate contents strictly
  for (const sname of candidates){
    try{
      const res = await fetch('/api/sheets?sheet=' + encodeURIComponent(sname), { headers: { 'Accept': 'application/json' } });
      const jrRaw = await res.json().catch(()=>null);
      // handle server-side wrapper { __sheet, rows }
      const jr = Array.isArray(jrRaw) ? jrRaw : (jrRaw && Array.isArray(jrRaw.rows) ? jrRaw.rows : jrRaw);
      if (Array.isArray(jr) && jr.length){
        const sample = jr[0];
        if (looksLikeCompDet(sample)){
          rows = jr;
          sourceSheet = sname;
          console.debug('COMPOSER_DEBUG selected sheet (api):', sname, 'headers:', Object.keys(sample));
          break;
        } else {
          console.debug('COMPOSER_DEBUG rejected sheet (api):', sname, 'headers:', Object.keys(sample));
        }
      } else {
        console.debug('COMPOSER_DEBUG no-array or empty from API for', sname, jr);
      }
    }catch(e){
      console.debug('COMPOSER_DEBUG api fetch failed for', sname, e);
    }
  }

  // 2) If not found via API, try GViz client-side fetch (same strict checks)
  if (!rows || rows.length === 0){
    for (const sname of candidates){
      try {
        const g = await gvizFetch(sname);
        if (!g || !g.rows || !g.rows.length) continue;
        const headers = g.cols.map(h => String(h).trim() || '');
        // build a sample object mapping header->value for the first row
        const sampleObj = {};
        for (let i = 0; i < headers.length; i++){
          const hk = headers[i] || `col${i+1}`;
          sampleObj[hk] = g.rows[0][i];
        }
        if (!looksLikeCompDet(sampleObj)) continue;
        // assemble rows as objects (header -> value)
        rows = g.rows.map(r => {
          const obj = {};
          for (let i = 0; i < headers.length; i++){
            const hk = headers[i] || `col${i+1}`;
            obj[hk] = (r[i] !== undefined && r[i] !== null) ? r[i] : '';
          }
          return obj;
        });
        sourceSheet = sname;
        // we've found a suitable CompDet-like sheet via GViz; stop searching
        break;
      } catch (e) {
        console.debug('COMPOSER_DEBUG gviz fetch failed for', sname, e);
      }
    }
  }

  // If still nothing, explain and show a tiny debug hint
  if (!rows || rows.length === 0){
    content.innerHTML = `<div>No composer detail sheet (CompDet) could be located. I tried: ${candidates.join(', ')}.</div>`;
    if (clearBtn) clearBtn.style.display = 'none';
    return;
  }

  // Now find a matching row inside the selected rows
  let matchRow = null;
  let foundVal = null;
  const target = String(name || '').trim();
  const normTarget = normVal(target);

  // Preferred: check 'composer'-like column if present
  const sampleKeys = Object.keys(rows[0] || {});
  const composerKey = sampleKeys.find(k => normalizeKey(k).includes('composer') || normalizeKey(k).includes('композитор'));

  if (composerKey){
    // search for composerKey matches first (more reliable)
    for (const r of rows){
      const val = String(r[composerKey] || '').trim();
      if (!val) continue;
      const nv = normVal(val);
      if (nv === normTarget || nv.includes(normTarget) || normTarget.includes(nv)){
        matchRow = r;
        foundVal = val;
        break;
      }
    }
  }

  // fallback: full-row scan
  if (!matchRow){
    for (const r of rows){
      for (const v of Object.values(r)){
        if (!v) continue;
        const str = String(v || '').trim();
        const nv = normVal(str);
        if (nv === normTarget || nv.includes(normTarget) || normTarget.includes(nv)){
          matchRow = r;
          foundVal = str;
          break;
        }
      }
      if (matchRow) break;
    }
  }

  // If still not found, surface a helpful message + a small sample for debugging
  if (!matchRow){
    const samplePreview = escapeHtml(JSON.stringify(rows[0] || {}, null, 2));
    content.innerHTML = `<div>No composer match in ${escapeHtml(sourceSheet || 'CompDet')} for <strong>${escapeHtml(name)}</strong>.</div>
      <div style="margin-top:8px;color:#6b7280;font-size:0.9rem">Sample headers from detected sheet (for debugging):</div>
      <pre style="max-height:220px;overflow:auto;background:#fafafa;border:1px solid #eee;padding:8px;border-radius:6px;font-size:0.85rem">${samplePreview}</pre>`;
    if (clearBtn) clearBtn.style.display = 'inline-block';
    return;
  }

  // Build rowObj (robust conversion)
  let rowObj = {};
  if (Array.isArray(matchRow)){
    // if row is an array, map by sample keys if possible
    const sampleObj = (rows && rows.length && typeof rows[0] === 'object') ? rows[0] : null;
    if (sampleObj){
      const sampleKeys = Object.keys(sampleObj);
      for (let i=0;i<matchRow.length;i++){
        rowObj[sampleKeys[i] || `col${i+1}`] = matchRow[i];
      }
    } else {
      for (let i=0;i<matchRow.length;i++) rowObj[`col${i+1}`] = matchRow[i];
    }
  } else if (typeof matchRow === 'object' && matchRow){
    rowObj = matchRow;
  }

  // QUICK RENDER: if the caller provided the original result row, show a fast lightweight
  // composer view immediately so the user sees details on first click. The rest of this
  // function will continue and may replace the content with a richer CompDet lookup.
  if (row && typeof row === 'object' && Object.keys(row).length){
    const pick = (keys) => { for (const k of keys){ if (row[k] !== undefined && row[k] !== null && String(row[k]).trim() !== '') return String(row[k]); } return ''; };
    const pickPos = (idx) => { try{ if (Array.isArray(row) && row.length>idx) return String(row[idx]); }catch(_){ } return ''; };

    const A_quick = pick(['A','colA','Composer','composer','Name','name']) || pickPos(0) || '';
    const B_quick = pick(['B','colB','Lifespan','lifespan']) || pickPos(1) || '';
  const C_quick = pick(['C','colC','Russian','russian']) || pickPos(2) || '';
  const C_quick_label = (Object.keys(row).find(k=>String(k).trim().toUpperCase()==='C') || 'Russian');
  const D_quick_key = (Object.keys(row).find(k=>String(k).trim().toUpperCase()==='D') || 'D');
    // Use the cell value in column D as the label when present (user requested)
    let D_quick_label = '';
    try{
      if (sampleKeys && sampleKeys[3] && rowObj && rowObj.hasOwnProperty(sampleKeys[3])) D_quick_label = String(rowObj[sampleKeys[3]] || '');
      if (!D_quick_label) D_quick_label = (pick([D_quick_key, 'D', 'colD', 'Label', 'label']) || D_quick_key || 'D');
    }catch(e){ D_quick_label = (pick([D_quick_key, 'D', 'colD', 'Label', 'label']) || D_quick_key || 'D'); }
    const E_quick = pick(['E','colE','Value','value']) || pickPos(4) || '';
    const F_quick = pick(['F','colF','Country','country','Nationality']) || pickPos(5) || '';
    const G_quick = pick(['G','colG','Soviet republic','republic']) || pickPos(6) || '';
    const H_quick = pick(['H','colH','Gender','gender']) || pickPos(7) || '';
    const I_quick = pick(['I','colI','Notes','notes']) || pickPos(8) || '';

    content.innerHTML = `
      <div>
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;"><h1 style="margin:0 0 6px 0; font-size:1.25rem">${escapeHtml(A_quick)}</h1><span class="spinner" aria-hidden="true" title="Loading more details"></span></div>
        ${B_quick ? `<p style="margin:0 0 8px 0"><i>${escapeHtml(B_quick)}</i></p>` : ''}
        <br/>
        <p style="margin:6px 0"><b>${escapeHtml(C_quick_label)}:</b> ${escapeHtml(C_quick)}</p>
        <p style="margin:6px 0"><b>${escapeHtml(D_quick_label)}:</b> ${escapeHtml(E_quick)}</p>
        <br/>
        <p style="margin:6px 0"><b>${escapeHtml(Object.keys(row).find(k=>String(k).trim().toUpperCase()==='F') || 'Country')}:</b> ${escapeHtml(F_quick)}</p>
        <p style="margin:6px 0"><b>${escapeHtml(Object.keys(row).find(k=>String(k).trim().toUpperCase()==='G') || 'Soviet Republic')}:</b> ${escapeHtml(G_quick)}</p>
        <br/>
        <p style="margin:6px 0"><b>${escapeHtml(Object.keys(row).find(k=>String(k).trim().toUpperCase()==='H') || 'Gender')}:</b> ${escapeHtml(H_quick)}</p>
        <p style="margin:6px 0"><b>${escapeHtml(Object.keys(row).find(k=>String(k).trim().toUpperCase()==='I') || 'Notes')}:</b> ${escapeHtml(I_quick)}</p>
      </div>
    `;
    if (clearBtn) clearBtn.style.display = 'inline-block';
    // continue on to richer lookup below
  }

  
  
  

  // labels we want to show (adjust as you like)
  const desired = ['Composer','Lifespan','Country','Soviet republic','Nationality','Language','Notes','Learn more'];

  // normalize keys map
  const normMap = {};
  Object.keys(rowObj || {}).forEach(k => {
    try { normMap[normalizeKey(k)] = rowObj[k]; }
    catch { normMap[String(k||'')] = rowObj[k]; }
  });

  // Special handling when the source is the MusicList aggregation sheet.
  // Some MusicList exports use single-letter column headers (A,B,C...) or moved
  // columns; support the common mapping provided by the spreadsheet owner.
  if (sourceSheet === 'MusicList'){
    const getByLetters = (letters, fallbacks=[]) => {
      for (const L of letters){ if (rowObj.hasOwnProperty(L) && rowObj[L] !== undefined && rowObj[L] !== null && String(rowObj[L]).trim() !== '') return String(rowObj[L]); }
      for (const fb of fallbacks){ for (const k of Object.keys(rowObj)){ if (String(k||'').toLowerCase().trim() === fb.toLowerCase().trim() && rowObj[k]) return String(rowObj[k]); } }
      return '';
    };

    const colA = getByLetters(['A','colA','Composer','composer','name']);
    const colN = getByLetters(['B','colN','Lifespan','lifespan','Years']);
    const colB = getByLetters(['C','colB','Russian','russian']);
    const labelFromP = getByLetters(['D','P','Label','label']);
    const valueFromC = getByLetters(['E','C','Value','native']);
    const colK = getByLetters(['F','K','Country','country']);
    const colO = getByLetters(['G','O','Soviet republic','republic']);
    const colQ = getByLetters(['I','Q','Notes','notes']);

    if (colA) normMap['composer'] = colA;
    if (colN) normMap['lifespan'] = colN;
    if (colB) normMap['russian'] = colB;
    if (labelFromP && valueFromC) normMap[normalizeKey(labelFromP)] = valueFromC;
    if (colK) normMap['country'] = colK;
    if (colO) normMap['soviet republic'] = colO;
    if (colQ) normMap['notes'] = colQ;
  }

  // helper to find candidate data by a list of label fragments
  const getValForLabels = (labels) => {
    for (const lab of labels){
      const nk = normalizeKey(lab);
      if (nk && (nk in normMap) && normMap[nk] !== undefined && normMap[nk] !== null && String(normMap[nk]).trim() !== '') {
        return String(normMap[nk]);
      }
    }
    // heuristics: return first lifespan-like value if present
    const allValues = Object.values(normMap||{}).map(v => v==null? '': String(v));
    const lifeHintRegex = /\b\d{3,4}\s*[–—-]\s*\d{2,4}\b|\b\d{3,4}\b/;
    for (const v of allValues){
      if (v && lifeHintRegex.test(String(v))) return v;
    }
    // last resort: first non-empty
    for (const v of allValues){ if (v && String(v).trim() !== '') return v; }
    return '';
  };

  const headerAliases = {
    'Composer': ['Composer','Композитор','composer','Name','name'],
    'Lifespan': ['Lifespan','Life span','Born','Died','Years'],
    'Country': ['Country','country','Страна','Country of birth','Nationality'],
    'Soviet republic': ['Soviet republic','Republic','Soviet'],
    'Nationality': ['Nationality','Nationality (EN)'],
    'Language': ['Language','language','Язык'],
    'Notes': ['Notes','notes','Примечания'],
    'Learn more': ['Learn more','Link','URL']
  };

  const values = desired.map(h => {
    const aliases = headerAliases[h] || [h];
    const v = getValForLabels(aliases);
    return v == null ? '' : String(v);
  });

  // prefer Lifespan for the small italic line shown under the composer name
  const lifespanIndex = desired.indexOf('Lifespan');
  const lifespanRaw = (lifespanIndex >= 0 ? (values[lifespanIndex] || '') : '') || '';
  const cleanDisplay = s => String(s || '').replace(/[\r\n\t]+/g,' ').replace(/\s+/g,' ').trim();
  const dispFound = cleanDisplay(foundVal);
  const dispLifespan = cleanDisplay(lifespanRaw);
  const sourceHtml = sourceSheet ? `<div style="margin-top:6px;color:#6b7280;font-size:0.85rem">Source: ${escapeHtml(sourceSheet)}</div>` : '';

  // prefer Lifespan for the small italic line shown under the composer name
  const colEHtml = dispLifespan ? `<div style="margin-top:4px;color:#6b7280;font-style:italic;font-size:0.95rem">${escapeHtml(dispLifespan)}</div>` : '';

  // Helper: find the actual key in rowObj that corresponds to a single-letter column (A..Z)
  const findKeyForLetter = (L) => {
    if (!L) return null;
    const plain = String(L).trim().toLowerCase();
    // exact match
    const exact = Object.keys(rowObj).find(k => String(k||'').trim().toLowerCase() === plain);
    if (exact) return exact;
    // common "colX" style
    const colForms = Object.keys(rowObj).find(k => String(k||'').toLowerCase().replace(/[^a-z0-9]/g,'') === ('col' + plain).replace(/[^a-z0-9]/g,''));
    if (colForms) return colForms;
    // try uppercase single-letter header
    const upper = Object.keys(rowObj).find(k => String(k||'').trim() === String(L).toUpperCase());
    if (upper) return upper;
    // fallback by position using sampleKeys (A->0, B->1...)
    try{
      const idx = String(L).toUpperCase().charCodeAt(0) - 65;
      if (typeof sampleKeys !== 'undefined' && Array.isArray(sampleKeys) && idx >= 0 && idx < sampleKeys.length) return sampleKeys[idx];
    }catch(_){ }
    return null;
  };

  const getValForKey = (k) => { if (!k) return ''; const v = rowObj[k]; return v == null ? '' : String(v); };

  // Pull the requested columns A..I
  const A = getValForKey(findKeyForLetter('A'));
  const B = getValForKey(findKeyForLetter('B'));
  const C = getValForKey(findKeyForLetter('C'));
  const D_key = findKeyForLetter('D');
  const D_label = D_key ? String(D_key) : 'D';
  const E = getValForKey(findKeyForLetter('E'));
  const F = getValForKey(findKeyForLetter('F'));
  const G = getValForKey(findKeyForLetter('G'));
  const H = getValForKey(findKeyForLetter('H'));
  const I = getValForKey(findKeyForLetter('I'));

  // Determine human-friendly labels using the actual header keys if available
  const C_label = findKeyForLetter('C') || 'Russian';
  // Prefer the cell value in column D as the label if available
  let D_label_final = D_label;
  try{ if (rowObj && Object.keys(rowObj)[3] && rowObj[Object.keys(rowObj)[3]]) D_label_final = String(rowObj[Object.keys(rowObj)[3]]); }catch(e){}
  const F_label = findKeyForLetter('F') || 'Country';
  const G_label = findKeyForLetter('G') || 'Soviet Republic';
  const H_label = findKeyForLetter('H') || 'Gender';
  const I_label = findKeyForLetter('I') || 'Notes';

  // Render only the composer heading and the requested formatted block
  content.innerHTML = `
    <div>
      <h1 style="margin:0 0 6px 0; font-size:1.25rem">${escapeHtml(A)}</h1>
      ${B ? `<p style="margin:0 0 8px 0"><i>${escapeHtml(B)}</i></p>` : ''}
  <br/>
  <p style="margin:6px 0"><b>${escapeHtml(C_label)}:</b> ${escapeHtml(C)}</p>
  <p style="margin:6px 0"><b>${escapeHtml(D_label_final)}:</b> ${escapeHtml(E)}</p>
  <br/>
  <p style="margin:6px 0"><b>${escapeHtml(F_label)}:</b> ${escapeHtml(F)}</p>
  <p style="margin:6px 0"><b>${escapeHtml(G_label)}:</b> ${escapeHtml(G)}</p>
  <br/>
  <p style="margin:6px 0"><b>${escapeHtml(H_label)}:</b> ${escapeHtml(H)}</p>
  <p style="margin:6px 0"><b>${escapeHtml(I_label)}:</b> ${escapeHtml(I)}</p>
    </div>
    `;

  if (clearBtn) {
    clearBtn.style.display = 'inline-block';
    clearBtn.onclick = () => {
      selectedComposer = '';
      if (clearBtn) clearBtn.style.display = 'none';
      populateComposerBox('', null);
      currentPage = 1;
      loadResults();
    };
  }
}

// Initialization: populate filters and load initial results
(async function init(){
  try{
    const resultsList = document.getElementById('results-list'); if (resultsList) resultsList.innerHTML = '<div class="result-item"><em>Loading results…</em></div>';
    const fc = document.getElementById('filter-country'); if (fc) fc.innerHTML = '<div style="color:#6b7280">Loading…</div>';
    const fd = document.getElementById('filter-decade'); if (fd) fd.innerHTML = '<div style="color:#6b7280">Loading…</div>';
    const ft = document.getElementById('filter-type'); if (ft) ft.innerHTML = '<div style="color:#6b7280">Loading…</div>';

    // run population in parallel but don't fail the whole init if one fails
    await Promise.allSettled([populateCountryCheckboxes(), populateDecadeCheckboxes(), populateTypeCheckboxes()]);

    // wire search button and Enter key
    const sbtn = document.getElementById('qbtn'); if (sbtn) sbtn.addEventListener('click', ()=>{ currentPage = 1; loadResults(); });
    if (qinput) qinput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') { currentPage = 1; loadResults(); } });

    // wire clear-all-filters button in the left Filters box
    try{
      const caf = document.getElementById('clear-all-filters-btn'); if (caf) caf.addEventListener('click', ()=>{ clearAllFilters(); });
    }catch(e){}

    // ensure composer box starts empty
    try{ populateComposerBox('', null); }catch(_){}

    // finally load results
    await loadResults();
  }catch(e){
    const resultsEl = document.getElementById('results'); if (resultsEl) resultsEl.innerText = 'Initialization failed: ' + String(e);
    console.error('Initialization failed', e);
  }
})();
